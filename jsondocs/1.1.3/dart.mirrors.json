{"dependencies":[{"kind":"library","name":"dart:core","id":"dart.core","comment":"\n\nBuilt-in types, collections,\nand other core functionality for every Dart program.\n\nThis library is automatically imported.\n\nSome classes in this library,\nsuch as [String] and [num],\nsupport Dart's built-in data types.\nOther classes, such as [List] and [Map], provide data structures\nfor managing collections of objects.\nAnd still other classes represent commonly used types of data\nsuch as URIs, dates and times, and errors.\n\n## Numbers and booleans\n\n[int] and [double] provide support for Dart's built-in numerical data types:\nintegers and double-precision floating point numbers, respectively.\nAn object of type [bool] is either true or false.\nVariables of these types can be constructed from literals:\n\n    int meaningOfLife = 42;\n    double valueOfPi  = 3.141592;\n    bool visible      = true;\n\n## Strings and regular expressions\n\nA [String] is immutable and represents a sequence of characters.\n\n    String shakespeareQuote = \"All the world's a stage, ...\";\n\n[StringBuffer] provides a way to construct strings efficiently.\n\n    StringBuffer moreShakespeare = new StringBuffer();\n    moreShakespeare.write('And all the men and women ');\n    moreShakespeare.write('merely players; ...');\n\nThe String and StringBuffer classes implement string concatenation,\ninterpolation, and other string manipulation features.\n\n    String philosophy = 'Live on ';\n    String get palindrome => philosophy + philosophy.split('').reversed.join();\n\n[RegExp] implements Dart regular expressions,\nwhich provide a grammar for matching patterns within text.\nFor example, here's a regular expression that matches\na string of one or more digits:\n\n    var numbers = new RegExp(r'\\d+');\n\nDart regular expressions have the same syntax and semantics as\nJavaScript regular expressions. See\n<http://ecma-international.org/ecma-262/5.1/#sec-15.10>\nfor the specification of JavaScript regular expressions.\n\n## Collections\n\nThe dart:core library provides basic collections,\nsuch as [List], [Map], and [Set].\n\nA List is an ordered collection of objects, with a length.\nLists are sometimes called arrays.\nUse a List when you need to access objects by index.\n\n    List superheroes = [ 'Batman', 'Superman', 'Harry Potter' ];\n\nA Set is an unordered collection of unique objects.\nYou cannot get an item by index (position).\nAdding a duplicate item has no effect.\n\n    Set villains = new Set();\n    villains.add('Joker');\n    villains.addAll( ['Lex Luther', 'Voldemort'] );\n\nA Map is an unordered collection of key-value pairs.\nMaps are sometimes called associative arrays because\nmaps associate a key to some value for easy retrieval.\nKeys are unique.\nUse a Map when you need to access objects\nby a unique identifier.\n\n    Map sidekicks = { 'Batman': 'Robin',\n                      'Superman': 'Lois Lane',\n                      'Harry Potter': 'Ron and Hermione' };\n\nIn addition to these classes,\ndart:core contains [Iterable],\nan interface that defines functionality\ncommon in collections of objects.\nExamples include the ability\nto run a function on each element in the collection,\nto apply a test to each element,\nto retrieve an object, and to determine length.\n\nIterable is implemented by List and Set,\nand used by Map for its keys and values.\n\nFor other kinds of collections, check out the\n[dart:collection](#dart-collection) library.\n\n## Date and time\n\nUse [DateTime] to represent a point in time\nand [Duration] to represent a span of time.\n\nYou can create DateTime objects with constructors\nor by parsing a correctly formatted string.\n\n    DateTime now = new DateTime.now();\n    DateTime berlinWallFell = new DateTime(1989, 11, 9);\n    DateTime moonLanding = DateTime.parse(\"1969-07-20\");\n\nCreate a Duration object specifying the individual time units.\n\n    Duration timeRemaining = new Duration(hours:56, minutes:14);\n\nIn addition to DateTime and Duration,\ndart:core contains the [Stopwatch] class for measuring elapsed time.\n\n## Uri\n\nA [Uri] object represents a uniform resource identifier,\nwhich identifies a resource on the web.\n\n    Uri dartlang = Uri.parse('http://dartlang.org/');\n\n## Errors\n\nThe [Error] class represents the occurrence of an error\nduring runtime.\nSubclasses of this class represent specific kinds of errors.\n\n## Other documentation\n\nFor more information about how to use the built-in types, refer to\n[Built-in Types](http://www.dartlang.org/docs/dart-up-and-running/contents/ch02.html#built-in-types)\nin Chapter 2 of\n[Dart: Up and Running](http://www.dartlang.org/docs/dart-up-and-running/).\n\nAlso, see\n[dart:core - Numbers, Collections, Strings, and More](http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-dartcore---strings-collections-and-more)\nfor more coverage of classes in this package.\n\nThe\n[Dart Language Specification](http://www.dartlang.org/docs/spec/)\nprovides technical details.\n","children":[{"kind":"class","name":"Object","id":"Object","comment":"\nThe base class for all Dart objects.\n\nBecause Object is the root of the Dart class hierarchy,\nevery other Dart class is a subclass of Object.\n\nWhen you define a class, you should override [toString]\nto return a string describing an instance of that class.\nYou might also need to define [hashCode] and [==], as described in the\n[Implementing map keys]\n(http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-implementing-map-keys)\nsection of the [library tour]\n(http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html).\n","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"isOperator":true,"kind":"method","name":"==","id":"==1()","comment":"\nThe equality operator.\n\nThe default behavior for all [Object]s is to return true if and\nonly if [:this:] and [other] are the same object.\n\nOverride this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:\n\n * Total: It must return a boolean for all arguments. It should never throw\n   or return `null`.\n\n * Reflexive: For all objects `o`, `o == o` must be true.\n\n * Symmetric: For all objects `o1` and `o2`, `o1 == o2` and `o2 == o1` must\n   either both be true, or both be false.\n\n * Transitive: For all objects `o1`, `o2`, and `o3`, if `o1 == o2` and\n   `o2 == o3` are true, then `o1 == o3` must be true.\n\nThe method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.\n\nIf a subclass overrides the equality operator it should override\nthe [hashCode] method as well to maintain consistency.\n","children":[{"kind":"param","name":"other","id":"other"}],"line":"59"},{"returnType":{"name":"String","refId":"dart.core/String"},"kind":"method","name":"toString","id":"toString0()","comment":"\nReturns a string representation of this object.\n","line":"78"},{"kind":"method","name":"noSuchMethod","id":"noSuchMethod1()","comment":"\n[noSuchMethod] is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to [noSuchMethod] in an [Invocation].\nIf [noSuchMethod] returns a value, that value becomes the result of\nthe original invocation.\n\nThe default behavior of [noSuchMethod] is to throw a\n[NoSuchMethodError].\n","children":[{"ref":{"name":"Invocation","refId":"dart.core/Invocation"},"kind":"param","name":"invocation","id":"invocation"}],"line":"90"},{"ref":{"name":"int","refId":"dart.core/int"},"kind":"property","name":"hashCode","id":"hashCode","comment":"\nGet a hash code for this object.\n\nAll objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator [:==:]. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.\n\nIf a subclass overrides [hashCode] it should override the\nequality operator as well to maintain consistency.\n","line":"73"},{"ref":{"name":"Type","refId":"dart.core/Type"},"kind":"property","name":"runtimeType","id":"runtimeType","comment":"\nA representation of the runtime type of the object.\n","line":"95"},{"kind":"constructor","name":"","id":"0()","comment":"\nCreates a new [Object] instance.\n\n[Object] instances have no meaningful state, and are only useful\nthrough their identity. An [Object] instance is equal to itself\nonly.\n","line":"29"}],"uri":"dart-sdk/lib/core/object.dart","line":"21"}],"uri":"dart-sdk/lib/core/core.dart","line":"153"}],"kind":"library","name":"dart:mirrors","id":"dart.mirrors","comment":"\nBasic reflection in Dart,\nwith support for introspection and dynamic evaluation.\n\n*Introspection* is that subset of reflection by which a running\nprogram can examine its own structure. For example, a function\nthat prints out the names of all the members of an arbitrary object.\n\n*Dynamic evaluation* refers the ability to evaluate code that\nhas not been literally specified at compile time, such as calling a method\nwhose name is provided as an argument (because it is looked up\nin a database, or provided interactively by the user).\n\n## How to interpret this library's documentation\n\nAs a rule, the names of Dart declarations are represented using\ninstances of class [Symbol]. Whenever the doc speaks of an object *s*\nof class [Symbol] denoting a name, it means the string that\nwas used to construct *s*.\n\nThe documentation frequently abuses notation with\nDart pseudo-code such as [:o.x(a):], where\no and a are defined to be objects; what is actually meant in these\ncases is [:o'.x(a'):] where *o'* and *a'* are Dart variables\nbound to *o* and *a* respectively. Furthermore, *o'* and *a'*\nare assumed to be fresh variables (meaning that they are\ndistinct from any other variables in the program).\n\nSometimes the documentation refers to *serializable* objects.\nAn object is serializable across isolates if and only if it is an instance of\nnum, bool, String, a list of objects that are serializable\nacross isolates, or a map with keys and values that are all serializable across\nisolates.\n\n## Status: Unstable\n\nThe dart:mirrors library is unstable and its API might change slightly as a\nresult of user feedback. This library is platform dependent and therefore it\nhas implementations for both dart2js and the Dart VM. Both are under\ndevelopment and may not support all operations yet.\n","children":[{"returnType":{"name":"TypeMirror","refId":"dart.mirrors/TypeMirror"},"kind":"method","name":"reflectType","id":"reflectType1()","comment":"\nThis function returns a [TypeMirror] reflecting the type\nrepresented by [key].\n\nIf [key] is not an instance of [Type] then this function\nthrows an [ArgumentError].\n\nNote that since one cannot obtain a [Type] object from\nanother isolate, this function can only be used to\nobtain type mirrors on types of the current isolate.\n","children":[{"ref":{"name":"Type","refId":"dart.core/Type"},"kind":"param","name":"key","id":"key"}],"line":"175"},{"returnType":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"kind":"method","name":"reflectClass","id":"reflectClass1()","comment":"\nReflects a class declaration.\nLet *C* be the original class declaration of the class\nrepresented by [key].\nThis function returns a [ClassMirror] reflecting *C*.\n\nIf [key] is not an instance of [Type] then this function\nthrows an [ArgumentError]. If [key] is the Type for dynamic\nor a function typedef, throws an [ArgumentError].\n\nNote that since one cannot obtain a [Type] object from\nanother isolate, this function can only be used to\nobtain class mirrors on classes of the current isolate.\n","children":[{"ref":{"name":"Type","refId":"dart.core/Type"},"kind":"param","name":"key","id":"key"}],"line":"162"},{"returnType":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"kind":"method","name":"reflect","id":"reflect1()","comment":"\nReflects an instance.\nReturns an [InstanceMirror] reflecting [reflectee].\nIf [reflectee] is a function or an instance of a class\nthat has a [:call:] method, the returned instance mirror\nwill be a [ClosureMirror].\n\nNote that since one cannot obtain an object from\nanother isolate, this function can only be used to\nobtain  mirrors on objects of the current isolate.\n","children":[{"ref":{"name":"Object","refId":"dart.core/Object"},"kind":"param","name":"reflectee","id":"reflectee"}],"line":"146"},{"returnType":{"name":"MirrorSystem","refId":"dart.mirrors/MirrorSystem"},"kind":"method","name":"currentMirrorSystem","id":"currentMirrorSystem0()","comment":"\nReturns a [MirrorSystem] for the current isolate.\n","line":"133"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"kind":"class","name":"MirrorsUsed","id":"MirrorsUsed","comment":"\nAnnotation describing how \"dart:mirrors\" is used (EXPERIMENTAL).\n\nWhen used as metadata on an import of \"dart:mirrors\" in library *L*, this\nclass describes how \"dart:mirrors\" is used by library *L* unless overridden.\nSee [override].\n\nThe following text is non-normative:\n\nIn some scenarios, for example, when minifying Dart code, or when generating\nJavaScript code from a Dart program, the size and performance of the output\ncan suffer from use of reflection.  In those cases, telling the compiler\nwhat is used, can have a significant impact.\n\nExample usage:\n\n    @MirrorsUsed(symbols: 'foo', override: '*')\n    import 'dart:mirrors';\n\n    class Foo {\n      noSuchMethod(Invocation invocation) {\n        print(MirrorSystem.getName(invocation.memberName));\n      }\n    }\n\n    main() {\n      new Foo().foo(); // Prints \"foo\".\n      new Foo().bar(); // Might print an arbitrary (mangled) name, \"bar\".\n    }\n","children":[{"isFinal":true,"kind":"variable","name":"symbols","id":"symbols","comment":"\nThe list of strings passed to new [Symbol], and symbols that might be\npassed to [MirrorSystem.getName].\n\nCombined with the names of [targets], [metaTargets] and their members,\nthis forms the complete list of strings passed to new [Symbol], and\nsymbols that might be passed to [MirrorSystem.getName] by the library to\nwhich this metadata applies.\n\nThe following text is non-normative:\n\nSpecifying this option turns off the following warnings emitted by\ndart2js:\n\n* Using \"MirrorSystem.getName\" may result in larger output.\n* Using \"new #{name}\" may result in larger output.\n\nUse symbols = \"*\" to turn off the warnings mentioned above.\n\nFor example, if using [noSuchMethod] to interact with a database, extract\nall the possible column names and include them in this list.  Similarly,\nif using [noSuchMethod] to interact with another language (JavaScript, for\nexample) extract all the identifiers from API used and include them in\nthis list.\n","line":"1177"},{"isFinal":true,"kind":"variable","name":"targets","id":"targets","comment":"\nA list of reflective targets.\n\nCombined with [metaTargets], this provides the complete list of reflective\ntargets used by the library to which this metadata applies.\n\nThe following text is non-normative:\n\nFor now, there is no formal description of what a reflective target is.\nInformally, it is a list of things that are expected to have fully\nfunctional mirrors.\n","line":"1191"},{"isFinal":true,"kind":"variable","name":"metaTargets","id":"metaTargets","comment":"\nA list of classes that when used as metadata indicates a reflective\ntarget.\n\nSee [targets].\n","line":"1199"},{"isFinal":true,"kind":"variable","name":"override","id":"override","comment":"\nA list of library names or \"*\".\n\nWhen used as metadata on an import of \"dart:mirrors\", this metadata does\nnot apply to the library in which the annotation is used, but instead\napplies to the other libraries (all libraries if \"*\" is used).\n","line":"1208"},{"kind":"constructor","name":"","id":"4()","children":[{"isOptional":true,"isNamed":true,"initializedField":{"name":"symbols","refId":"dart.mirrors/MirrorsUsed/symbols"},"kind":"param","name":"symbols","id":"symbols","line":"1211"},{"isOptional":true,"isNamed":true,"initializedField":{"name":"targets","refId":"dart.mirrors/MirrorsUsed/targets"},"kind":"param","name":"targets","id":"targets","line":"1211"},{"isOptional":true,"isNamed":true,"initializedField":{"name":"metaTargets","refId":"dart.mirrors/MirrorsUsed/metaTargets"},"kind":"param","name":"metaTargets","id":"metaTargets","line":"1211"},{"isOptional":true,"isNamed":true,"initializedField":{"name":"override","refId":"dart.mirrors/MirrorsUsed/override"},"kind":"param","name":"override","id":"override","line":"1211"}],"line":"1210"}],"line":"1146"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"kind":"class","name":"Comment","id":"Comment","comment":"\nClass used for encoding comments as metadata annotations.\n","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isFinal":true,"kind":"variable","name":"text","id":"text","comment":"\nThe comment text as written in the source text.\n","line":"1094"},{"ref":{"name":"String","refId":"dart.core/String"},"isFinal":true,"kind":"variable","name":"trimmedText","id":"trimmedText","comment":"\nThe comment text without the start, end, and padding text.\n\nFor example, if [text] is [: /** Comment text. */ :] then the [trimmedText]\nis [: Comment text. :].\n","line":"1102"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isFinal":true,"kind":"variable","name":"isDocComment","id":"isDocComment","comment":"\nIs [:true:] if this comment is a documentation comment.\n\nThat is, that the comment is either enclosed in [: /** ... */ :] or starts\nwith [: /// :].\n","line":"1110"},{"kind":"constructor","name":"","id":"3()","children":[{"ref":{"name":"String","refId":"dart.core/String"},"initializedField":{"name":"text","refId":"dart.mirrors/Comment/text"},"kind":"param","name":"text","id":"text"},{"ref":{"name":"String","refId":"dart.core/String"},"initializedField":{"name":"trimmedText","refId":"dart.mirrors/Comment/trimmedText"},"kind":"param","name":"trimmedText","id":"trimmedText"},{"ref":{"name":"bool","refId":"dart.core/bool"},"initializedField":{"name":"isDocComment","refId":"dart.mirrors/Comment/isDocComment"},"kind":"param","name":"isDocComment","id":"isDocComment"}],"line":"1112"}],"line":"1090"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"kind":"class","name":"SourceLocation","id":"SourceLocation","comment":"\nA [SourceLocation] describes the span of an entity in Dart source code.\n","line":"1084"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"interfaces":[{"name":"VariableMirror","refId":"dart.mirrors/VariableMirror"}],"kind":"class","name":"ParameterMirror","id":"ParameterMirror","comment":"\nA [ParameterMirror] reflects a Dart formal parameter declaration.\n","children":[{"ref":{"name":"TypeMirror","refId":"dart.mirrors/TypeMirror"},"kind":"property","name":"type","id":"type","comment":"\nA mirror on the type of this parameter.\n","line":"1052"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isOptional","id":"isOptional","comment":"\nReturns [:true:] if the reflectee is an optional parameter.\nOtherwise returns [:false:].\n","line":"1058"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isNamed","id":"isNamed","comment":"\nReturns [:true:] if the reflectee is a named parameter.\nOtherwise returns [:false:].\n","line":"1064"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"hasDefaultValue","id":"hasDefaultValue","comment":"\nReturns [:true:] if the reflectee has explicitly declared a default value.\nOtherwise returns [:false:].\n","line":"1070"},{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"kind":"property","name":"defaultValue","id":"defaultValue","comment":"\nIf this is a required parameter, returns [:null:]. Otherwise returns a\nmirror on the default value for this parameter. If no default is declared\nfor an optional parameter, the default is [:null:] and a mirror on [:null:]\nis returned.\n","line":"1078"}],"line":"1048"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"interfaces":[{"name":"DeclarationMirror","refId":"dart.mirrors/DeclarationMirror"}],"kind":"class","name":"VariableMirror","id":"VariableMirror","comment":"\nA [VariableMirror] reflects a Dart language variable declaration.\n","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"isOperator":true,"kind":"method","name":"==","id":"==1()","comment":"\nReturns true if this mirror is equal to [other].\n\nThe equality holds if and only if\n(1) [other] is a mirror of the same kind\nand\n(2)  [:simpleName == other.simpleName:] and\n[:owner == other.owner:].\n","children":[{"kind":"param","name":"other","id":"other"}],"line":"1042"},{"ref":{"name":"TypeMirror","refId":"dart.mirrors/TypeMirror"},"kind":"property","name":"type","id":"type","comment":"\nReturns a mirror on the type of the reflectee.\n","line":"1010"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isStatic","id":"isStatic","comment":"\nReturns [:true:] if the reflectee is a static variable.\nOtherwise returns [:false:].\n\nFor the purposes of the mirror library, top-level variables are\nimplicitly declared static.\n","line":"1019"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isFinal","id":"isFinal","comment":"\nReturns [:true:] if the reflectee is a final variable.\nOtherwise returns [:false:].\n","line":"1025"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isConst","id":"isConst","comment":"\nReturns [:true:] if the reflectee is declared [:const:].\nOtherwise returns [:false:].\n","line":"1031"}],"line":"1006"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"interfaces":[{"name":"DeclarationMirror","refId":"dart.mirrors/DeclarationMirror"}],"kind":"class","name":"MethodMirror","id":"MethodMirror","comment":"\nA [MethodMirror] reflects a Dart language function, method,\nconstructor, getter, or setter.\n","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"isOperator":true,"kind":"method","name":"==","id":"==1()","comment":"\nReturns true if this mirror is equal to [other].\n\nThe equality holds if and only if\n(1) [other] is a mirror of the same kind\nand\n(2) [:simpleName == other.simpleName:] and\n[:owner == other.owner:].\n","children":[{"kind":"param","name":"other","id":"other"}],"line":"1000"},{"ref":{"name":"TypeMirror","refId":"dart.mirrors/TypeMirror"},"kind":"property","name":"returnType","id":"returnType","comment":"\nA mirror on the return type for the reflectee.\n","line":"897"},{"ref":{"name":"String","refId":"dart.core/String"},"kind":"property","name":"source","id":"source","comment":"\nThe source code for the reflectee, if available. Otherwise null.\n","line":"902"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"ParameterMirror","refId":"dart.mirrors/ParameterMirror"}]},"kind":"property","name":"parameters","id":"parameters","comment":"\nA list of mirrors on the parameters for the reflectee.\n","line":"907"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isStatic","id":"isStatic","comment":"\nIs the reflectee static?\n\nFor the purposes of the mirrors library, a top-level function is\nconsidered static.\n","line":"915"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isAbstract","id":"isAbstract","comment":"\nIs the reflectee abstract?\n","line":"920"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isSynthetic","id":"isSynthetic","comment":"\nReturns true if the reflectee is synthetic, and returns false otherwise.\n\nA reflectee is synthetic if it is a getter or setter implicitly introduced\nfor a field or Type, or if it is a constructor that was implicitly\nintroduced as a default constructor or as part of a mixin application.\n","line":"929"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isRegularMethod","id":"isRegularMethod","comment":"\nIs the reflectee a regular function or method?\n\nA function or method is regular if it is not a getter, setter, or\nconstructor.  Note that operators, by this definition, are\nregular methods.\n","line":"938"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isOperator","id":"isOperator","comment":"\nIs the reflectee an operator?\n","line":"943"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isGetter","id":"isGetter","comment":"\nIs the reflectee a getter?\n","line":"948"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isSetter","id":"isSetter","comment":"\nIs the reflectee a setter?\n","line":"953"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isConstructor","id":"isConstructor","comment":"\nIs the reflectee a constructor?\n","line":"958"},{"ref":{"name":"Symbol","refId":"dart.core/Symbol"},"kind":"property","name":"constructorName","id":"constructorName","comment":"\nThe constructor name for named constructors and factory methods.\n\nFor unnamed constructors, this is the empty string.  For\nnon-constructors, this is the empty string.\n\nFor example, [:'bar':] is the constructor name for constructor\n[:Foo.bar:] of type [:Foo:].\n","line":"969"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isConstConstructor","id":"isConstConstructor","comment":"\nIs the reflectee a const constructor?\n","line":"974"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isGenerativeConstructor","id":"isGenerativeConstructor","comment":"\nIs the reflectee a generative constructor?\n","line":"979"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isRedirectingConstructor","id":"isRedirectingConstructor","comment":"\nIs the reflectee a redirecting constructor?\n","line":"984"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isFactoryConstructor","id":"isFactoryConstructor","comment":"\nIs the reflectee a factory constructor?\n","line":"989"}],"line":"893"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"interfaces":[{"name":"TypeMirror","refId":"dart.mirrors/TypeMirror"}],"kind":"class","name":"TypedefMirror","id":"TypedefMirror","comment":"\nA [TypedefMirror] represents a typedef in a Dart language program.\n","children":[{"ref":{"name":"FunctionTypeMirror","refId":"dart.mirrors/FunctionTypeMirror"},"kind":"property","name":"referent","id":"referent","comment":"\nThe defining type for this typedef.\nIf the the type referred to by the reflectee is a function type \n*F*, the result will be [:FunctionTypeMirror:] reflecting *F*\nwhich is abstract and has an abstract method [:call:] whose \nsignature corresponds to *F*.\n\nFor instance [:void f(int):] is the referent for [:typedef void f(int):].\n","line":"886"}],"line":"876"},{"superclass":{"name":"TypeMirror","refId":"dart.mirrors/TypeMirror"},"isAbstract":true,"kind":"class","name":"TypeVariableMirror","id":"TypeVariableMirror","comment":"\nA [TypeVariableMirror] represents a type parameter of a generic\ntype.\n","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"isOperator":true,"kind":"method","name":"==","id":"==1()","comment":"\nReturns [:true:] if this mirror is equal to [other].\nOtherwise returns [:false:].\n\nThe equality holds if and only if\n(1) [other] is a mirror of the same kind\nand\n(2)  [:simpleName == other.simpleName:] and\n[:owner == other.owner:].\n","children":[{"kind":"param","name":"other","id":"other"}],"line":"870"},{"ref":{"name":"TypeMirror","refId":"dart.mirrors/TypeMirror"},"kind":"property","name":"upperBound","id":"upperBound","comment":"\nA mirror on the type that is the upper bound of this type variable.\n","line":"858"}],"line":"854"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"interfaces":[{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"}],"kind":"class","name":"FunctionTypeMirror","id":"FunctionTypeMirror","comment":"\nA [FunctionTypeMirror] represents the type of a function in the\nDart language.\n","children":[{"ref":{"name":"TypeMirror","refId":"dart.mirrors/TypeMirror"},"kind":"property","name":"returnType","id":"returnType","comment":"\nReturns the return type of the reflectee.\n","line":"837"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"ParameterMirror","refId":"dart.mirrors/ParameterMirror"}]},"kind":"property","name":"parameters","id":"parameters","comment":"\nReturns a list of the parameter types of the reflectee.\n","line":"842"},{"ref":{"name":"MethodMirror","refId":"dart.mirrors/MethodMirror"},"kind":"property","name":"callMethod","id":"callMethod","comment":"\nA mirror on the [:call:] method for the reflectee.\n","line":"847"}],"line":"833"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"interfaces":[{"name":"ObjectMirror","refId":"dart.mirrors/ObjectMirror"},{"name":"TypeMirror","refId":"dart.mirrors/TypeMirror"}],"kind":"class","name":"ClassMirror","id":"ClassMirror","comment":"\nA [ClassMirror] reflects a Dart language class.\n","children":[{"returnType":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"kind":"method","name":"newInstance","id":"newInstance3()","comment":"\nInvokes the named constructor and returns a mirror on the result.\n\nLet *c* be the class reflected by this mirror\nlet *a1, ..., an* be the elements of [positionalArguments]\nlet *k1, ..., km* be the identifiers denoted by the elements of\n[namedArguments.keys]\nand let *v1, ..., vm* be the elements of [namedArguments.values].\nIf [constructorName] was created from the empty string\nThen this method will execute the instance creation expression\n*new c(a1, ..., an, k1: v1, ..., km: vm)*\nin a scope that has access to the private members\nof *c*. Otherwise, let\n*f* be the simple name of the constructor denoted by [constructorName]\nThen this method will execute the instance creation expression\n *new c.f(a1, ..., an, k1: v1, ..., km: vm)*\nin a scope that has access to the private members\nof *c*.\nIn either case:\nIf the expression evaluates to a result *r*, this method returns\nthe result of calling [reflect](*r*).\nIf evaluating the expression causes a compilation error\nthe effect is the same as if a non-reflective compilation error\nhad been encountered.\nIf evaluating the expression throws an exception *e*\n(that it does not catch)\nthis method throws *e*.\n","children":[{"ref":{"name":"Symbol","refId":"dart.core/Symbol"},"kind":"param","name":"constructorName","id":"constructorName"},{"ref":{"name":"List","refId":"dart.core/List"},"kind":"param","name":"positionalArguments","id":"positionalArguments","line":"788"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"Symbol","refId":"dart.core/Symbol"}]},"isOptional":true,"kind":"param","name":"namedArguments","id":"namedArguments","line":"789"}],"line":"787"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"isOperator":true,"kind":"method","name":"==","id":"==1()","comment":"\nReturns [:true:] if this mirror is equal to [other].\nOtherwise returns [:false:].\n\nThe equality holds if and only if\n(1) [other] is a mirror of the same kind\nand\n(2) This mirror and [other] reflect the same class.\n\nNote that if the reflected class is an invocation of\na generic class,(2) implies that the reflected class\nand [other] have equal type arguments.\n","children":[{"kind":"param","name":"other","id":"other"}],"line":"804"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"isOperator":true,"kind":"method","name":"[]","id":"[]1()","comment":"\nIf [:declarations[name]:] is a regular method m, the result of this method\nis a closure equivalent to:\n\n    (r1, ..., rn, {p1: d1, ..., pk: dk}) {\n      return this.invoke(name, [r1, ..., rn], {#p1: p1, ..., #pk: pk});\n    }\n\nif m has required parameters r1, ..., rn, and named parameters p1, ..., pk\nwith defaults d1, ..., dk. The result of this method is a\nclosure equivalent to:\n\n    (r1, ..., rn, [p1 = d1, ..., pk = dk]) {\n      return this.invoke(name, [r1, ..., rn, p1, ..., pk]);\n    }\n\nif m has required parameters r1, ..., rn, and optional positional\nparameters p1, ..., pk with defaults d1, ..., dk.  Otherwise, an\n[ArgumentError] is thrown.\n","children":[{"ref":{"name":"Symbol","refId":"dart.core/Symbol"},"kind":"param","name":"name","id":"name"}],"line":"826"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"hasReflectedType","id":"hasReflectedType","comment":"\nReturns true if this mirror reflects a non-generic class or an instantiated\ngeneric class in the current isolate. Otherwise, returns false.\n","line":"687"},{"ref":{"name":"Type","refId":"dart.core/Type"},"kind":"property","name":"reflectedType","id":"reflectedType","comment":"\nIf [:hasReflectedType:] returns true, returns the corresponding [Type].\nOtherwise, an [UnsupportedError] is thrown.\n","line":"693"},{"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"kind":"property","name":"superclass","id":"superclass","comment":"\nA mirror on the superclass on the reflectee.\n\nIf this type is [:Object:], the superclass will be null.\n","line":"700"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"}]},"kind":"property","name":"superinterfaces","id":"superinterfaces","comment":"\nA list of mirrors on the superinterfaces of the reflectee.\n","line":"705"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"Symbol","refId":"dart.core/Symbol"},{"name":"DeclarationMirror","refId":"dart.mirrors/DeclarationMirror"}]},"kind":"property","name":"declarations","id":"declarations","comment":"\nReturns an immutable map of the declarations actually given in the class\ndeclaration.\n\nThis map includes all regular methods, getters, setters, fields,\nconstructors and type variables actually declared in the class. Both\nstatic and instance members are included, but no inherited members are\nincluded. The map is keyed by the simple names of the declarations.\n\nThis does not include inherited members.\n","line":"718"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"Symbol","refId":"dart.core/Symbol"},{"name":"MethodMirror","refId":"dart.mirrors/MethodMirror"}]},"kind":"property","name":"instanceMembers","id":"instanceMembers","comment":"\nReturns a map of the methods, getters and setters of an instance of the\nclass.\n\nThe intent is to capture those members that constitute the API of an\ninstance. Hence fields are not included, but the getters and setters\nimplicitly introduced by fields are included. The map includes methods,\ngetters and setters that are inherited as well as those introduced by the\nclass itself.\n\nThe map is keyed by the simple names of the members.\n","line":"732"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"Symbol","refId":"dart.core/Symbol"},{"name":"MethodMirror","refId":"dart.mirrors/MethodMirror"}]},"kind":"property","name":"staticMembers","id":"staticMembers","comment":"\nReturns a map of the static methods, getters and setters of the class.\n\nThe intent is to capture those members that constitute the API of a class.\nHence fields are not included, but the getters and setters implicitly\nintroduced by fields are included.\n\nThe map is keyed by the simple names of the members.\n","line":"743"},{"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"kind":"property","name":"mixin","id":"mixin","comment":"\nThe mixin of this class.\nIf this class is the result of a mixin application of the\nform S with M, returns a class mirror on M.\nOtherwise returns a class mirror on [reflectee].\n","line":"752"}],"line":"682"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"interfaces":[{"name":"DeclarationMirror","refId":"dart.mirrors/DeclarationMirror"}],"kind":"class","name":"TypeMirror","id":"TypeMirror","comment":"\nA [TypeMirror] reflects a Dart language class, typedef,\nfunction type or type variable.\n","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"TypeVariableMirror","refId":"dart.mirrors/TypeVariableMirror"}]},"kind":"property","name":"typeVariables","id":"typeVariables","comment":"\nAn immutable list with mirrors for all type variables for this type.\n\nIf this type is a generic declaration or an invocation of a generic\ndeclaration, the returned list contains mirrors on the type variables\ndeclared in the original declaration.\nOtherwise, the returned list is empty.\n\nThis list preserves the order of declaration of the type variables.\n","line":"639"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"TypeMirror","refId":"dart.mirrors/TypeMirror"}]},"kind":"property","name":"typeArguments","id":"typeArguments","comment":"\nAn immutable list with mirrors for all type arguments for\nthis type.\n\nIf the reflectee is an invocation of a generic class,\nthe type arguments are the bindings of its type parameters.\nIf the reflectee is the original declaration of a generic,\nit has no type arguments and this method returns an empty list.\nIf the reflectee is not generic, then\nit has no type arguments and this method returns an empty list.\n\nThis list preserves the order of declaration of the type variables.\n","line":"654"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isOriginalDeclaration","id":"isOriginalDeclaration","comment":"\nIs this the original declaration of this type?\n\nFor most classes, they are their own original declaration.  For\ngeneric classes, however, there is a distinction between the\noriginal class declaration, which has unbound type variables, and\nthe instantiations of generic classes, which have bound type\nvariables.\n","line":"665"},{"ref":{"name":"TypeMirror","refId":"dart.mirrors/TypeMirror"},"kind":"property","name":"originalDeclaration","id":"originalDeclaration","comment":"\nA mirror on the original declaration of this type.\n\nFor most classes, they are their own original declaration.  For\ngeneric classes, however, there is a distinction between the\noriginal class declaration, which has unbound type variables, and\nthe instantiations of generic classes, which have bound type\nvariables.\n","line":"676"}],"line":"628"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"interfaces":[{"name":"ObjectMirror","refId":"dart.mirrors/ObjectMirror"},{"name":"DeclarationMirror","refId":"dart.mirrors/DeclarationMirror"}],"kind":"class","name":"LibraryMirror","id":"LibraryMirror","comment":"\nA [LibraryMirror] reflects a Dart language library, providing\naccess to the variables, functions, and classes of the\nlibrary.\n","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"isOperator":true,"kind":"method","name":"==","id":"==1()","comment":"\nReturns [:true:] if this mirror is equal to [other].\nOtherwise returns [:false:].\n\nThe equality holds if and only if\n(1) [other] is a mirror of the same kind\nand\n(2)  The library being reflected by this mirror\nand the library being reflected by [other]\nare\nthe same library in the same isolate.\n","children":[{"kind":"param","name":"other","id":"other"}],"line":"599"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"isOperator":true,"kind":"method","name":"[]","id":"[]1()","comment":"\nIf [:declarations[name]:] is a regular method m, the result of this method\nis a closure equivalent to:\n\n    (r1, ..., rn, {p1: d1, ..., pk: dk}) {\n      return this.invoke(name, [r1, ..., rn], {#p1: p1, ..., #pk: pk});\n    }\n\nif m has required parameters r1, ..., rn, and named parameters p1, ..., pk\nwith defaults d1, ..., dk. The result of this method is a\nclosure equivalent to:\n\n    (r1, ..., rn, [p1 = d1, ..., pk = dk]) {\n      return this.invoke(name, [r1, ..., rn, p1, ..., pk]);\n    }\n\nif m has required parameters r1, ..., rn, and optional positional\nparameters p1, ..., pk with defaults d1, ..., dk.  Otherwise, an\n[ArgumentError] is thrown.\n","children":[{"ref":{"name":"Symbol","refId":"dart.core/Symbol"},"kind":"param","name":"name","id":"name"}],"line":"621"},{"ref":{"name":"Uri","refId":"dart.core/Uri"},"kind":"property","name":"uri","id":"uri","comment":"\nThe absolute uri of the library.\n","line":"564"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"Symbol","refId":"dart.core/Symbol"},{"name":"DeclarationMirror","refId":"dart.mirrors/DeclarationMirror"}]},"kind":"property","name":"declarations","id":"declarations","comment":"\nReturns an immutable map of the declarations actually given in the library.\n\nThis map includes all regular methods, getters, setters, fields, classes\nand typedefs actually declared in the library. The map is keyed by the\nsimple names of the declarations.\n","line":"573"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"Symbol","refId":"dart.core/Symbol"},{"name":"MethodMirror","refId":"dart.mirrors/MethodMirror"}]},"kind":"property","name":"topLevelMembers","id":"topLevelMembers","comment":"\nReturns a map of the top-level methods, getters and setters of the library.\n\nThe intent is to capture those members that constitute the API of a\nlibrary. Hence fields are not included, but the getters and setters\nimplicitly introduced by fields are included. Synthetic getters for the\ntypes exported by the library are also included.\n\nThe map is keyed by the simple names of the members.\n","line":"585"}],"line":"560"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"interfaces":[{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"}],"kind":"class","name":"ClosureMirror","id":"ClosureMirror","comment":"\nA [ClosureMirror] reflects a closure.\n\nA [ClosureMirror] provides access to its captured variables and\nprovides the ability to execute its reflectee.\n","children":[{"returnType":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"kind":"method","name":"apply","id":"apply2()","comment":"\nExecutes the closure and returns a mirror on the result.\nLet *f* be the closure reflected by this mirror,\nlet *a1, ..., an* be the elements of [positionalArguments]\nlet *k1, ..., km* be the identifiers denoted by the elements of\n[namedArguments.keys]\nand let *v1, ..., vm* be the elements of [namedArguments.values].\nThen this method will perform the method invocation\n *f(a1, ..., an, k1: v1, ..., km: vm)*\nIf the invocation returns a result *r*, this method returns\nthe result of calling [reflect](*r*).\nIf the invocation causes a compilation error\nthe effect is the same as if a non-reflective compilation error\nhad been encountered.\nIf the invocation throws an exception *e* (that it does not catch)\nthis method throws *e*.\n","children":[{"ref":{"name":"List","refId":"dart.core/List"},"kind":"param","name":"positionalArguments","id":"positionalArguments"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"Symbol","refId":"dart.core/Symbol"}]},"isOptional":true,"kind":"param","name":"namedArguments","id":"namedArguments","line":"547"}],"line":"546"},{"returnType":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"kind":"method","name":"findInContext","id":"findInContext2()","comment":"\nNot yet supported. Calling this method throws an [UnsupportedError].\n","children":[{"ref":{"name":"Symbol","refId":"dart.core/Symbol"},"kind":"param","name":"name","id":"name"},{"defaultValue":"null","isOptional":true,"isNamed":true,"kind":"param","name":"ifAbsent","id":"ifAbsent"}],"line":"552"},{"ref":{"name":"MethodMirror","refId":"dart.mirrors/MethodMirror"},"kind":"property","name":"function","id":"function","comment":"\nA mirror on the function associated with this closure.\n\nThe function associated with an implicit closure of a function is that\nfunction.\n\nThe function associated with an instance of a class that has a [:call:]\nmethod is that [:call:] method.\n","line":"527"}],"line":"517"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"interfaces":[{"name":"ObjectMirror","refId":"dart.mirrors/ObjectMirror"}],"kind":"class","name":"InstanceMirror","id":"InstanceMirror","comment":"\nAn [InstanceMirror] reflects an instance of a Dart language object.\n","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"isOperator":true,"kind":"method","name":"==","id":"==1()","comment":"\nReturns true if this mirror is equal to [other].\nThe equality holds if and only if\n(1) [other] is a mirror of the same kind\nand\n(2) either\n(a) [hasReflectee] is true and so is\n[:identical(reflectee, other.reflectee):]\nor\n(b) the remote objects reflected by this mirror and\nby [other] are identical.\n","children":[{"kind":"param","name":"other","id":"other"}],"line":"474"},{"kind":"method","name":"delegate","id":"delegate1()","comment":"\nPerform [invocation] on [reflectee].\nEquivalent to\n\nthis.invoke(invocation.memberName,\n            invocation.positionalArguments,\n            invocation.namedArguments);\n","children":[{"ref":{"name":"Invocation","refId":"dart.core/Invocation"},"kind":"param","name":"invocation","id":"invocation"}],"line":"484"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"isOperator":true,"kind":"method","name":"[]","id":"[]1()","comment":"\nReturns a closure for invoking the regular method named [name].\n\nIf [:type.instanceLookup(name):] returns a regular method m, the result of\nthis method is a closure equivalent to:\n\n    (r1, ..., rn, {p1: d1, ..., pk: dk}) {\n      return this.invoke(name, [r1, ..., rn], {#p1: p1,  ..., #pk: pk});\n    }\n\nif m has required parameters r1, ..., rn, and named parameters p1, ..., pk\nwith defaults d1, ..., dk. The result of this method is a\nclosure equivalent to:\n\n    (r1, ..., rn, [p1 = d1, ..., pk = dk]) {\n      return this.invoke(name, [r1, ..., rn, p1, ..., pk]);\n    }\n\nif m has required parameters r1, ..., rn, and optional positional\nparameters p1, ..., pk with defaults d1, ..., dk.  Otherwise, an\n[ArgumentError] is thrown.\n","children":[{"ref":{"name":"Symbol","refId":"dart.core/Symbol"},"kind":"param","name":"name","id":"name"}],"line":"508"},{"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"kind":"property","name":"type","id":"type","comment":"\nA mirror on the type of the reflectee.\n\nReturns a mirror on the actual class of the reflectee.\nThe class of the reflectee may differ from\nthe object returned by invoking [runtimeType] on\nthe reflectee.\n","line":"436"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"hasReflectee","id":"hasReflectee","comment":"\nDoes [reflectee] contain the instance reflected by this mirror?\nThis will always be true in the local case (reflecting instances\nin the same isolate), but only true in the remote case if this\nmirror reflects a simple value.\n\nA value is simple if one of the following holds:\n - the value is [:null:]\n - the value is of type [num]\n - the value is of type [bool]\n - the value is of type [String]\n","line":"450"},{"kind":"property","name":"reflectee","id":"reflectee","comment":"\nIf the [InstanceMirror] reflects an instance it is meaningful to\nhave a local reference to, we provide access to the actual\ninstance here.\n\nIf you access [reflectee] when [hasReflectee] is false, an\nexception is thrown.\n","line":"460"}],"line":"427"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"interfaces":[{"name":"Mirror","refId":"dart.mirrors/Mirror"}],"kind":"class","name":"ObjectMirror","id":"ObjectMirror","comment":"\nAn [ObjectMirror] is a common superinterface of [InstanceMirror],\n[ClassMirror], and [LibraryMirror] that represents their shared\nfunctionality.\n\nFor the purposes of the mirrors library, these types are all\nobject-like, in that they support method invocation and field\naccess.  Real Dart objects are represented by the [InstanceMirror]\ntype.\n\nSee [InstanceMirror], [ClassMirror], and [LibraryMirror].\n","children":[{"returnType":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"kind":"method","name":"invoke","id":"invoke3()","comment":"\nInvokes the named function and returns a mirror on the result.\n\nLet *o* be the object reflected by this mirror, let\n*f* be the simple name of the member denoted by [memberName],\nlet *a1, ..., an* be the elements of [positionalArguments]\nlet *k1, ..., km* be the identifiers denoted by the elements of\n[namedArguments.keys]\nand let *v1, ..., vm* be the elements of [namedArguments.values].\nThen this method will perform the method invocation\n *o.f(a1, ..., an, k1: v1, ..., km: vm)*\nin a scope that has access to the private members\nof *o* (if *o* is a class or library) or the private members of the\nclass of *o* (otherwise).\nIf the invocation returns a result *r*, this method returns\nthe result of calling [reflect](*r*).\nIf the invocation causes a compilation error\nthe effect is the same as if a non-reflective compilation error\nhad been encountered.\nIf the invocation throws an exception *e* (that it does not catch)\nthis method throws *e*.\n","children":[{"ref":{"name":"Symbol","refId":"dart.core/Symbol"},"kind":"param","name":"memberName","id":"memberName"},{"ref":{"name":"List","refId":"dart.core/List"},"kind":"param","name":"positionalArguments","id":"positionalArguments","line":"359"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"Symbol","refId":"dart.core/Symbol"}]},"isOptional":true,"kind":"param","name":"namedArguments","id":"namedArguments","line":"360"}],"line":"358"},{"returnType":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"kind":"method","name":"getField","id":"getField1()","comment":"\nInvokes a getter and returns a mirror on the result. The getter\ncan be the implicit getter for a field or a user-defined getter\nmethod.\n\nLet *o* be the object reflected by this mirror, let\n*f* be the simple name of the getter denoted by [fieldName],\nThen this method will perform the getter invocation\n *o.f*\nin a scope that has access to the private members\nof *o* (if *o* is a class or library) or the private members of the\nclass of *o* (otherwise).\n\nIf this mirror is an [InstanceMirror], and [fieldName] denotes an instance\nmethod on its reflectee, the result of the invocation is an instance\nmirror on a closure corresponding to that method.\n\nIf this mirror is a [LibraryMirror], and [fieldName] denotes a top-level\nmethod in the corresponding library, the result of the invocation is an\ninstance mirror on a closure corresponding to that method.\n\nIf this mirror is a [ClassMirror], and [fieldName] denotes a static method\nin the corresponding class, the result of the invocation is an instance\nmirror on a closure corresponding to that method.\n\nIf the invocation returns a result *r*, this method returns\nthe result of calling [reflect](*r*).\nIf the invocation causes a compilation error\nthe effect is the same as if a non-reflective compilation error\nhad been encountered.\nIf the invocation throws an exception *e* (that it does not catch)\nthis method throws *e*.\n","children":[{"ref":{"name":"Symbol","refId":"dart.core/Symbol"},"kind":"param","name":"fieldName","id":"fieldName"}],"line":"397"},{"returnType":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"kind":"method","name":"setField","id":"setField2()","comment":"\nInvokes a setter and returns a mirror on the result. The setter\nmay be either the implicit setter for a non-final field or a\nuser-defined setter method.\n\nLet *o* be the object reflected by this mirror, let\n*f* be the simple name of the getter denoted by [fieldName],\nand let *a* be the object bound to [value].\nThen this method will perform the setter invocation\n*o.f = a*\nin a scope that has access to the private members\nof *o* (if *o* is a class or library) or the private members of the\nclass of *o* (otherwise).\nIf the invocation returns a result *r*, this method returns\nthe result of calling [reflect]([value]).\nIf the invocation causes a compilation error\nthe effect is the same as if a non-reflective compilation error\nhad been encountered.\nIf the invocation throws an exception *e* (that it does not catch)\nthis method throws *e*.\n","children":[{"ref":{"name":"Symbol","refId":"dart.core/Symbol"},"kind":"param","name":"fieldName","id":"fieldName"},{"ref":{"name":"Object","refId":"dart.core/Object"},"kind":"param","name":"value","id":"value"}],"line":"421"}],"line":"330"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"interfaces":[{"name":"Mirror","refId":"dart.mirrors/Mirror"}],"kind":"class","name":"DeclarationMirror","id":"DeclarationMirror","comment":"\nA [DeclarationMirror] reflects some entity declared in a Dart program.\n","children":[{"ref":{"name":"Symbol","refId":"dart.core/Symbol"},"kind":"property","name":"simpleName","id":"simpleName","comment":"\nThe simple name for this Dart language entity.\n\nThe simple name is in most cases the the identifier name of the\nentity, such as 'method' for a method [:void method() {...}:] or\n'mylibrary' for a [:library 'mylibrary';:] declaration.\n","line":"230"},{"ref":{"name":"Symbol","refId":"dart.core/Symbol"},"kind":"property","name":"qualifiedName","id":"qualifiedName","comment":"\nThe fully-qualified name for this Dart language entity.\n\nThis name is qualified by the name of the owner. For instance,\nthe qualified name of a method 'method' in class 'Class' in\nlibrary 'library' is 'library.Class.method'.\n\nReturns a [Symbol] constructed from a string representing the\nfully qualified name of the reflectee.\nLet *o* be the [owner] of this mirror, let *r* be the reflectee of\nthis mirror, let *p* be the fully qualified\nname of the reflectee of *o*, and let *s* be the simple name of *r*\ncomputed by [simpleName].\nThe fully qualified name of *r* is the\nconcatenation of *p*, '.', and *s*.\n\nBecause an isolate can contain more than one library with the same name (at\ndifferent URIs), a fully-qualified name does not uniquely identify any\nlanguage entity.\n","line":"252"},{"ref":{"name":"DeclarationMirror","refId":"dart.mirrors/DeclarationMirror"},"kind":"property","name":"owner","id":"owner","comment":"\nA mirror on the owner of this Dart language entity. This is the declaration\nimmediately surrounding the reflectee.\n\nFor a library, the owner is [:null:].\nFor a class declaration, typedef or top level function\nor variable, the owner is the enclosing library.\nFor a mixin application *S with M*, the owner is the owner\nof *M*.\nFor a constructor, the owner is the immediately enclosing class.\nFor a method, instance variable or\na static variable, the owner is the immediately enclosing class,\nunless the class is a mixin application *S with M*, in which case\nthe owner is *M*. Note that *M* may be an invocation of a generic.\nFor a parameter, local variable or local function the owner is the\nimmediately enclosing function.\n","line":"271"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isPrivate","id":"isPrivate","comment":"\nReturns [:true:] if this declaration is considered private\naccording to the Dart language specification.\nAlways returns [: false :] if this declaration\nis a library.\nOtherwise return [:false:].\n\n","line":"281"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isTopLevel","id":"isTopLevel","comment":"\nIs this declaration top-level?\n\nThis is defined to be equivalent to:\n   [:mirror.owner != null && mirror.owner is LibraryMirror:]\n","line":"289"},{"ref":{"name":"SourceLocation","refId":"dart.mirrors/SourceLocation"},"kind":"property","name":"location","id":"location","comment":"\nThe source location of this Dart language entity.\n\nThis operation is optional and may return [:null:].\n","line":"296"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"}]},"kind":"property","name":"metadata","id":"metadata","comment":"\nA list of the metadata associated with this declaration.\n\nLet *D* be the declaration this mirror reflects.\nIf *D* is decorated with annotations *A1, ..., An*\nwhere *n > 0*, then for each annotation *Ai* associated\nwith *D, 1 <= i <= n*, let *ci* be the constant object\nspecified by *Ai*. Then this method returns a list whose\nmembers are instance mirrors on *c1, ..., cn*.\nIf no annotations are associated with *D*, then\nan empty list is returned.\n\nIf evaluating any of *c1, ..., cn* would cause a\ncompilation error\nthe effect is the same as if a non-reflective compilation error\nhad been encountered.\n","line":"315"}],"line":"222"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"interfaces":[{"name":"Mirror","refId":"dart.mirrors/Mirror"}],"kind":"class","name":"IsolateMirror","id":"IsolateMirror","comment":"\nAn [IsolateMirror] reflects an isolate.\n","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"isOperator":true,"kind":"method","name":"==","id":"==1()","comment":"\nReturns [:true:] if this mirror is equal to [other].\nOtherwise returns [:false:].\nThe equality holds if and only if\n(1) [other] is a mirror of the same kind\nand\n(2) the isolate being reflected by this mirror is the same\nisolate being reflected by [other].\n","children":[{"kind":"param","name":"other","id":"other"}],"line":"216"},{"ref":{"name":"String","refId":"dart.core/String"},"kind":"property","name":"debugName","id":"debugName","comment":"\nReturns a unique name used to refer to an isolate\nin debugging messages.\n","line":"192"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"isCurrent","id":"isCurrent","comment":"\nReturns [:true:] if and only if this mirror reflects\nthe currently running isolate. Otherwise returns\n[:false:].\n","line":"199"},{"ref":{"name":"LibraryMirror","refId":"dart.mirrors/LibraryMirror"},"kind":"property","name":"rootLibrary","id":"rootLibrary","comment":"\nReturns a [LibraryMirror] on the root library for this\nisolate.\n","line":"205"}],"line":"187"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"kind":"class","name":"Mirror","id":"Mirror","comment":"\nA [Mirror] reflects some Dart language entity.\n\nEvery [Mirror] originates from some [MirrorSystem].\n","line":"182"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"kind":"class","name":"MirrorSystem","id":"MirrorSystem","comment":"\nA [MirrorSystem] is the main interface used to reflect on a set of\nassociated libraries.\n\nAt runtime each running isolate has a distinct [MirrorSystem].\n\nIt is also possible to have a [MirrorSystem] which represents a set\nof libraries which are not running -- perhaps at compile-time.  In\nthis case, all available reflective functionality would be\nsupported, but runtime functionality (such as invoking a function\nor inspecting the contents of a variable) would fail dynamically.\n","children":[{"returnType":{"name":"LibraryMirror","refId":"dart.mirrors/LibraryMirror"},"kind":"method","name":"findLibrary","id":"findLibrary1()","comment":"\nReturns the unique library named [libraryName] if it exists.\n\nIf no unique library exists, an error is thrown.\n","children":[{"ref":{"name":"Symbol","refId":"dart.core/Symbol"},"kind":"param","name":"libraryName","id":"libraryName"}],"line":"85"},{"returnType":{"name":"String","refId":"dart.core/String"},"isStatic":true,"kind":"method","name":"getName","id":"getName1()","comment":"\nReturns the name of [symbol].\n\nThe following text is non-normative:\n\nUsing this method may result in larger output.  If possible, use\n[MirrorsUsed] to specify which symbols must be retained in clear text.\n","children":[{"ref":{"name":"Symbol","refId":"dart.core/Symbol"},"kind":"param","name":"symbol","id":"symbol"}],"line":"114"},{"returnType":{"name":"Symbol","refId":"dart.core/Symbol"},"isStatic":true,"kind":"method","name":"getSymbol","id":"getSymbol2()","comment":"\nReturns a symbol for [name]. If [library] is not a [LibraryMirror] or if\n[name] is a private identifier and [library] is [:null:], throws an\n[ArgumentError]. If [name] is a private identifier, the symbol returned is\nwith respect to [library].\n\nThe following text is non-normative:\n\nUsing this method may result in larger output.  If possible, use\nthe const constructor of Symbol or symbol literals.\n","children":[{"ref":{"name":"String","refId":"dart.core/String"},"kind":"param","name":"name","id":"name"},{"ref":{"name":"LibraryMirror","refId":"dart.mirrors/LibraryMirror"},"isOptional":true,"kind":"param","name":"library","id":"library"}],"line":"127"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"Uri","refId":"dart.core/Uri"},{"name":"LibraryMirror","refId":"dart.mirrors/LibraryMirror"}]},"kind":"property","name":"libraries","id":"libraries","comment":"\nReturns an immutable map from URIs to mirrors for all\nlibraries known to this mirror system.\n","line":"78"},{"ref":{"name":"IsolateMirror","refId":"dart.mirrors/IsolateMirror"},"kind":"property","name":"isolate","id":"isolate","comment":"\nA mirror on the isolate associated with this [MirrorSystem].\nThis may be null if this mirror system is not running.\n","line":"94"},{"ref":{"name":"TypeMirror","refId":"dart.mirrors/TypeMirror"},"kind":"property","name":"dynamicType","id":"dynamicType","comment":"\nA mirror on the [:dynamic:] type.\n","line":"99"},{"ref":{"name":"TypeMirror","refId":"dart.mirrors/TypeMirror"},"kind":"property","name":"voidType","id":"voidType","comment":"\nA mirror on the [:void:] type.\n","line":"104"}],"line":"73"}],"uri":"dart-sdk/lib/mirrors/mirrors.dart","line":"56"}