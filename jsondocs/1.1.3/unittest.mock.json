{"dependencies":[{"kind":"library","name":"dart:core","id":"dart.core","comment":"\n\nBuilt-in types, collections,\nand other core functionality for every Dart program.\n\nThis library is automatically imported.\n\nSome classes in this library,\nsuch as [String] and [num],\nsupport Dart's built-in data types.\nOther classes, such as [List] and [Map], provide data structures\nfor managing collections of objects.\nAnd still other classes represent commonly used types of data\nsuch as URIs, dates and times, and errors.\n\n## Numbers and booleans\n\n[int] and [double] provide support for Dart's built-in numerical data types:\nintegers and double-precision floating point numbers, respectively.\nAn object of type [bool] is either true or false.\nVariables of these types can be constructed from literals:\n\n    int meaningOfLife = 42;\n    double valueOfPi  = 3.141592;\n    bool visible      = true;\n\n## Strings and regular expressions\n\nA [String] is immutable and represents a sequence of characters.\n\n    String shakespeareQuote = \"All the world's a stage, ...\";\n\n[StringBuffer] provides a way to construct strings efficiently.\n\n    StringBuffer moreShakespeare = new StringBuffer();\n    moreShakespeare.write('And all the men and women ');\n    moreShakespeare.write('merely players; ...');\n\nThe String and StringBuffer classes implement string concatenation,\ninterpolation, and other string manipulation features.\n\n    String philosophy = 'Live on ';\n    String get palindrome => philosophy + philosophy.split('').reversed.join();\n\n[RegExp] implements Dart regular expressions,\nwhich provide a grammar for matching patterns within text.\nFor example, here's a regular expression that matches\na string of one or more digits:\n\n    var numbers = new RegExp(r'\\d+');\n\nDart regular expressions have the same syntax and semantics as\nJavaScript regular expressions. See\n<http://ecma-international.org/ecma-262/5.1/#sec-15.10>\nfor the specification of JavaScript regular expressions.\n\n## Collections\n\nThe dart:core library provides basic collections,\nsuch as [List], [Map], and [Set].\n\nA List is an ordered collection of objects, with a length.\nLists are sometimes called arrays.\nUse a List when you need to access objects by index.\n\n    List superheroes = [ 'Batman', 'Superman', 'Harry Potter' ];\n\nA Set is an unordered collection of unique objects.\nYou cannot get an item by index (position).\nAdding a duplicate item has no effect.\n\n    Set villains = new Set();\n    villains.add('Joker');\n    villains.addAll( ['Lex Luther', 'Voldemort'] );\n\nA Map is an unordered collection of key-value pairs.\nMaps are sometimes called associative arrays because\nmaps associate a key to some value for easy retrieval.\nKeys are unique.\nUse a Map when you need to access objects\nby a unique identifier.\n\n    Map sidekicks = { 'Batman': 'Robin',\n                      'Superman': 'Lois Lane',\n                      'Harry Potter': 'Ron and Hermione' };\n\nIn addition to these classes,\ndart:core contains [Iterable],\nan interface that defines functionality\ncommon in collections of objects.\nExamples include the ability\nto run a function on each element in the collection,\nto apply a test to each element,\nto retrieve an object, and to determine length.\n\nIterable is implemented by List and Set,\nand used by Map for its keys and values.\n\nFor other kinds of collections, check out the\n[dart:collection](#dart-collection) library.\n\n## Date and time\n\nUse [DateTime] to represent a point in time\nand [Duration] to represent a span of time.\n\nYou can create DateTime objects with constructors\nor by parsing a correctly formatted string.\n\n    DateTime now = new DateTime.now();\n    DateTime berlinWallFell = new DateTime(1989, 11, 9);\n    DateTime moonLanding = DateTime.parse(\"1969-07-20\");\n\nCreate a Duration object specifying the individual time units.\n\n    Duration timeRemaining = new Duration(hours:56, minutes:14);\n\nIn addition to DateTime and Duration,\ndart:core contains the [Stopwatch] class for measuring elapsed time.\n\n## Uri\n\nA [Uri] object represents a uniform resource identifier,\nwhich identifies a resource on the web.\n\n    Uri dartlang = Uri.parse('http://dartlang.org/');\n\n## Errors\n\nThe [Error] class represents the occurrence of an error\nduring runtime.\nSubclasses of this class represent specific kinds of errors.\n\n## Other documentation\n\nFor more information about how to use the built-in types, refer to\n[Built-in Types](http://www.dartlang.org/docs/dart-up-and-running/contents/ch02.html#built-in-types)\nin Chapter 2 of\n[Dart: Up and Running](http://www.dartlang.org/docs/dart-up-and-running/).\n\nAlso, see\n[dart:core - Numbers, Collections, Strings, and More](http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-dartcore---strings-collections-and-more)\nfor more coverage of classes in this package.\n\nThe\n[Dart Language Specification](http://www.dartlang.org/docs/spec/)\nprovides technical details.\n","children":[{"kind":"class","name":"Object","id":"Object","comment":"\nThe base class for all Dart objects.\n\nBecause Object is the root of the Dart class hierarchy,\nevery other Dart class is a subclass of Object.\n\nWhen you define a class, you should override [toString]\nto return a string describing an instance of that class.\nYou might also need to define [hashCode] and [==], as described in the\n[Implementing map keys]\n(http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-implementing-map-keys)\nsection of the [library tour]\n(http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html).\n","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"isOperator":true,"kind":"method","name":"==","id":"==1()","comment":"\nThe equality operator.\n\nThe default behavior for all [Object]s is to return true if and\nonly if [:this:] and [other] are the same object.\n\nOverride this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:\n\n * Total: It must return a boolean for all arguments. It should never throw\n   or return `null`.\n\n * Reflexive: For all objects `o`, `o == o` must be true.\n\n * Symmetric: For all objects `o1` and `o2`, `o1 == o2` and `o2 == o1` must\n   either both be true, or both be false.\n\n * Transitive: For all objects `o1`, `o2`, and `o3`, if `o1 == o2` and\n   `o2 == o3` are true, then `o1 == o3` must be true.\n\nThe method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.\n\nIf a subclass overrides the equality operator it should override\nthe [hashCode] method as well to maintain consistency.\n","children":[{"kind":"param","name":"other","id":"other"}],"line":"59"},{"returnType":{"name":"String","refId":"dart.core/String"},"kind":"method","name":"toString","id":"toString0()","comment":"\nReturns a string representation of this object.\n","line":"78"},{"kind":"method","name":"noSuchMethod","id":"noSuchMethod1()","comment":"\n[noSuchMethod] is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to [noSuchMethod] in an [Invocation].\nIf [noSuchMethod] returns a value, that value becomes the result of\nthe original invocation.\n\nThe default behavior of [noSuchMethod] is to throw a\n[NoSuchMethodError].\n","children":[{"ref":{"name":"Invocation","refId":"dart.core/Invocation"},"kind":"param","name":"invocation","id":"invocation"}],"line":"90"},{"ref":{"name":"int","refId":"dart.core/int"},"kind":"property","name":"hashCode","id":"hashCode","comment":"\nGet a hash code for this object.\n\nAll objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator [:==:]. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.\n\nIf a subclass overrides [hashCode] it should override the\nequality operator as well to maintain consistency.\n","line":"73"},{"ref":{"name":"Type","refId":"dart.core/Type"},"kind":"property","name":"runtimeType","id":"runtimeType","comment":"\nA representation of the runtime type of the object.\n","line":"95"},{"kind":"constructor","name":"","id":"0()","comment":"\nCreates a new [Object] instance.\n\n[Object] instances have no meaningful state, and are only useful\nthrough their identity. An [Object] instance is equal to itself\nonly.\n","line":"29"}],"uri":"dart-sdk/lib/core/object.dart","line":"21"}],"uri":"dart-sdk/lib/core/core.dart","line":"153"},{"kind":"library","name":"file:///home/ggirou/dev/dart/doc_diff/bin/packages/unittest/matcher.dart","id":"unittest.matcher","comment":"\nSupport for specifying test expectations,\nsuch as for unit tests.\n\nThis library is included in the\n[unittest package on pub.dartlang.org]\n(http://pub.dartlang.org/packages/unittest).\nImport this library into your Dart code with:\n\n    import 'package:unittest/matcher.dart';\n\nThe matcher library provides a third-generation assertion mechanism, drawing\ninspiration from [Hamcrest](http://code.google.com/p/hamcrest/).\nFor more information, see\n[Unit Testing with Dart]\n(http://www.dartlang.org/articles/dart-unit-tests/).\n","children":[{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"kind":"class","name":"FailureHandler","id":"FailureHandler","comment":"\nFailed matches are reported using a default IFailureHandler.\nThe default implementation simply throws [TestFailure]s;\nthis can be replaced by some other implementation of\nIFailureHandler by calling configureExpectHandler.\n","children":[{"returnType":{"name":"void","refId":"void"},"kind":"method","name":"fail","id":"fail1()","comment":"This handles failures given a textual decription ","children":[{"ref":{"name":"String","refId":"dart.core/String"},"kind":"param","name":"reason","id":"reason"}],"line":"91"},{"returnType":{"name":"void","refId":"void"},"kind":"method","name":"failMatch","id":"failMatch5()","comment":"\nThis handles failures given the actual [value], the [matcher]\nthe [reason] (argument from [expect]), some additonal [matchState]\ngenerated by the [matcher], and a verbose flag which controls in\nsome cases how much [matchState] information is used. It will use\nthese to create a detailed error message (typically by calling\nan [ErrorFormatter]) and then call [fail] with this message.\n","children":[{"kind":"param","name":"actual","id":"actual"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"param","name":"matcher","id":"matcher"},{"ref":{"name":"String","refId":"dart.core/String"},"kind":"param","name":"reason","id":"reason"},{"ref":{"name":"Map","refId":"dart.core/Map"},"kind":"param","name":"matchState","id":"matchState","line":"102"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"param","name":"verbose","id":"verbose","line":"102"}],"line":"101"}],"uri":"doc_diff/bin/packages/unittest/src/interfaces.dart","line":"89"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"kind":"class","name":"Matcher","id":"Matcher","comment":"\n[expect] Matchers must implement/extend the Matcher class.\nThe base Matcher class has a generic implementation of [describeMismatch]\nso this does not need to be provided unless a more clear description is\nrequired. The other two methods ([matches] and [describe])\nmust always be provided as they are highly matcher-specific.\n","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"kind":"method","name":"matches","id":"matches2()","comment":"\nThis does the matching of the actual vs expected values.\n[item] is the actual value. [matchState] can be supplied\nand may be used to add details about the mismatch that are too\ncostly to determine in [describeMismatch].\n","children":[{"kind":"param","name":"item","id":"item"},{"ref":{"name":"Map","refId":"dart.core/Map"},"kind":"param","name":"matchState","id":"matchState"}],"line":"64"},{"returnType":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"method","name":"describe","id":"describe1()","comment":"This builds a textual description of the matcher. ","children":[{"ref":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"param","name":"description","id":"description"}],"line":"67"},{"returnType":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"method","name":"describeMismatch","id":"describeMismatch4()","comment":"\nThis builds a textual description of a specific mismatch. [item]\nis the value that was tested by [matches]; [matchState] is\nthe [Map] that was passed to and supplemented by [matches]\nwith additional information about the mismact, and [mismatchDescription]\nis the [Description] that is being built to decribe the mismatch.\nA few matchers make use of the [verbose] flag to provide detailed\ninformation that is not typically included but can be of help in\ndiagnosing failures, such as stack traces.\n","children":[{"kind":"param","name":"item","id":"item"},{"ref":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"param","name":"mismatchDescription","id":"mismatchDescription"},{"ref":{"name":"Map","refId":"dart.core/Map"},"kind":"param","name":"matchState","id":"matchState","line":"80"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"param","name":"verbose","id":"verbose","line":"80"}],"line":"79"},{"kind":"constructor","name":"","id":"0()","line":"56"}],"uri":"doc_diff/bin/packages/unittest/src/interfaces.dart","line":"55"}],"uri":"doc_diff/bin/packages/unittest/matcher.dart","line":"21"}],"kind":"library","name":"file:///home/ggirou/dev/dart/doc_diff/bin/packages/unittest/mock.dart","id":"unittest.mock","comment":"\nA simple mocking/spy library.\n\n## Installing ##\n\nUse [pub][] to install this package. Add the following to your `pubspec.yaml`\nfile.\n\n    dependencies:\n      unittest: any\n\nThen run `pub install`.\n\nImport this into your Dart code with:\n\n    import 'package:unittest/mock.dart';\n\nFor more information, see the [unittest package on pub.dartlang.org]\n(http://pub.dartlang.org/packages/unittest).\n\n## Using ##\n\nTo create a mock objects for some class T, create a new class using:\n\n    class MockT extends Mock implements T {};\n\nThen specify the [Behavior] of the Mock for different methods using\n[when] (to select the method and parameters) and then the [Action]s\nfor the [Behavior] by calling [thenReturn], [alwaysReturn], [thenThrow],\n[alwaysThrow], [thenCall] or [alwaysCall].\n\n[thenReturn], [thenThrow] and [thenCall] are one-shot so you would\ntypically call these more than once to specify a sequence of actions;\nthis can be done with chained calls, e.g.:\n\n     m.when(callsTo('foo')).\n         thenReturn(0).thenReturn(1).thenReturn(2);\n\n[thenCall] and [alwaysCall] allow you to proxy mocked methods, chaining\nto some other implementation. This provides a way to implement 'spies'.\n\nFor getters and setters, use \"get foo\" and \"set foo\"-style arguments\nto [callsTo].\n\nYou can disable logging for a particular [Behavior] easily:\n\n    m.when(callsTo('bar')).logging = false;\n\nYou can then use the mock object. Once you are done, to verify the\nbehavior, use [getLogs] to extract a relevant subset of method call\nlogs and apply [Matchers] to these through calling [verify].\n\nA Mock can be given a name when constructed. In this case instead of\nkeeping its own log, it uses a shared log. This can be useful to get an\naudit trail of interleaved behavior. It is the responsibility of the user\nto ensure that mock names, if used, are unique.\n\nLimitations:\n\n* only positional parameters are supported (up to 10);\n* to mock getters you will need to include parentheses in the call\n      (e.g. m.length() will work but not m.length).\n\nHere is a simple example:\n\n    class MockList extends Mock implements List {};\n\n    List m = new MockList();\n    m.when(callsTo('add', anything)).alwaysReturn(0);\n\n    m.add('foo');\n    m.add('bar');\n\n    getLogs(m, callsTo('add', anything)).verify(happenedExactly(2));\n    getLogs(m, callsTo('add', 'foo')).verify(happenedOnce);\n    getLogs(m, callsTo('add', 'isNull)).verify(neverHappened);\n\nNote that we don't need to provide argument matchers for all arguments,\nbut we do need to provide arguments for all matchers. So this is allowed:\n\n    m.when(callsTo('add')).alwaysReturn(0);\n    m.add(1, 2);\n\nBut this is not allowed and will throw an exception:\n\n    m.when(callsTo('add', anything, anything)).alwaysReturn(0);\n    m.add(1);\n\nHere is a way to implement a 'spy', which is where we log the call\nbut then hand it off to some other function, which is the same\nmethod in a real instance of the class being mocked:\n\n    class Foo {\n      bar(a, b, c) => a + b + c;\n    }\n\n    class MockFoo extends Mock implements Foo {\n      Foo real;\n      MockFoo() {\n        real = new Foo();\n        this.when(callsTo('bar')).alwaysCall(real.bar);\n      }\n    }\n\nHowever, there is an even easier way, by calling [Mock.spy], e.g.:\n\n     var foo = new Foo();\n     var spy = new Mock.spy(foo);\n     print(spy.bar(1, 2, 3));\n\nSpys created with Mock.spy do not have user-defined behavior;\nthey are simply proxies,  and thus will throw an exception if\nyou call [when]. They capture all calls in the log, so you can\ndo assertions on their history, such as:\n\n      spy.getLogs(callsTo('bar')).verify(happenedOnce);\n\n[pub]: http://pub.dartlang.org\n","children":[{"returnType":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"method","name":"neverThrew","id":"neverThrew1()","comment":"\n[neverThrew] asserts that no matching call to a method threw\na value that matched [value].\n","children":[{"kind":"param","name":"value","id":"value"}],"line":"1240"},{"returnType":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"method","name":"sometimeThrew","id":"sometimeThrew1()","comment":"\n[sometimeThrew] asserts that at least one matching call to a method threw\na value that matched [value].\n","children":[{"kind":"param","name":"value","id":"value"}],"line":"1233"},{"returnType":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"method","name":"alwaysThrew","id":"alwaysThrew1()","comment":"\n[alwaysThrew] asserts that all matching calls to a method threw\na value that matched [value].\n","children":[{"kind":"param","name":"value","id":"value"}],"line":"1226"},{"returnType":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"method","name":"neverReturned","id":"neverReturned1()","comment":"\n[neverReturned] asserts that no matching calls to a method returned\na value that matched [value].\n","children":[{"kind":"param","name":"value","id":"value"}],"line":"1219"},{"returnType":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"method","name":"sometimeReturned","id":"sometimeReturned1()","comment":"\n[sometimeReturned] asserts that at least one matching call to a method\nreturned a value that matched [value].\n","children":[{"kind":"param","name":"value","id":"value"}],"line":"1212"},{"returnType":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"method","name":"alwaysReturned","id":"alwaysReturned1()","comment":"\n[alwaysReturned] asserts that all matching calls to a method returned\na value that matched [value].\n","children":[{"kind":"param","name":"value","id":"value"}],"line":"1205"},{"returnType":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"method","name":"throwing","id":"throwing1()","comment":"\n[throwing] matches log entrues where the call to a method threw\na value that matched [value].\n","children":[{"kind":"param","name":"value","id":"value"}],"line":"1106"},{"returnType":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"method","name":"returning","id":"returning1()","comment":"\n[returning] matches log entries where the call to a method returned\na value that matched [value].\n","children":[{"kind":"param","name":"value","id":"value"}],"line":"1099"},{"returnType":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"method","name":"happenedAtMost","id":"happenedAtMost1()","comment":"[happenedAtMost] matches a maximum number of calls. ","children":[{"kind":"param","name":"count","id":"count"}],"line":"1036"},{"returnType":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"method","name":"happenedAtLeast","id":"happenedAtLeast1()","comment":"[happenedAtLeast] matches a minimum number of calls. ","children":[{"kind":"param","name":"count","id":"count"}],"line":"1031"},{"returnType":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"method","name":"happenedExactly","id":"happenedExactly1()","comment":"[happenedExactly] matches an exact number of calls. ","children":[{"kind":"param","name":"count","id":"count"}],"line":"1026"},{"returnType":{"name":"String","refId":"dart.core/String"},"kind":"method","name":"_qualifiedName","id":"_qualifiedName2()","comment":"Utility function for optionally qualified method names ","children":[{"kind":"param","name":"owner","id":"owner"},{"ref":{"name":"String","refId":"dart.core/String"},"kind":"param","name":"method","id":"method"}],"isPrivate":true,"line":"463"},{"returnType":{"name":"CallMatcher","refId":"unittest.mock/CallMatcher"},"kind":"method","name":"callsTo","id":"callsTo11()","comment":"\nReturns a [CallMatcher] for the specified signature. [method] can be\nnull to match anything, or a literal [String], a predicate [Function],\nor a [Matcher]. The various arguments can be scalar values or [Matcher]s.\nTo match getters and setters, use \"get \" and \"set \" prefixes on the names.\nFor example, for a property \"foo\", you could use \"get foo\" and \"set foo\"\nas literal string arguments to callsTo to match the getter and setter\nof \"foo\".\n","children":[{"isOptional":true,"kind":"param","name":"method","id":"method"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg0","id":"arg0","line":"318"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg1","id":"arg1","line":"319"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg2","id":"arg2","line":"320"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg3","id":"arg3","line":"321"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg4","id":"arg4","line":"322"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg5","id":"arg5","line":"323"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg6","id":"arg6","line":"324"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg7","id":"arg7","line":"325"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg8","id":"arg8","line":"326"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg9","id":"arg9","line":"327"}],"line":"317"},{"returnType":{"name":"String","refId":"dart.core/String"},"kind":"method","name":"_mockingErrorFormatter","id":"_mockingErrorFormatter5()","comment":"\nThe error formatter for mocking is a bit different from the default one\nfor unit testing; instead of the third argument being a 'reason'\nit is instead a [signature] describing the method signature filter\nthat was used to select the logs that were verified.\n","children":[{"kind":"param","name":"actual","id":"actual"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"param","name":"matcher","id":"matcher"},{"ref":{"name":"String","refId":"dart.core/String"},"kind":"param","name":"signature","id":"signature"},{"ref":{"name":"Map","refId":"dart.core/Map"},"kind":"param","name":"matchState","id":"matchState","line":"139"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"param","name":"verbose","id":"verbose","line":"139"}],"isPrivate":true,"line":"138"},{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"variable","name":"sharedLog","id":"sharedLog","comment":"The shared log used for named mocks. ","line":"1244"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"variable","name":"happenedAtMostOnce","id":"happenedAtMostOnce","comment":"[happenedAtMostOnce] matches zero or one call. ","line":"1050"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"variable","name":"happenedAtLeastOnce","id":"happenedAtLeastOnce","comment":"[happenedAtLeastOnce] matches one or more calls. ","line":"1047"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"variable","name":"happenedOnce","id":"happenedOnce","comment":"[happenedOnce] matches exactly one call. ","line":"1044"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"variable","name":"neverHappened","id":"neverHappened","comment":"[neverHappened] matches zero calls. ","line":"1041"},{"kind":"variable","name":"_noArg","id":"_noArg","isPrivate":true,"line":"172"},{"ref":{"name":"_MockFailureHandler","refId":"unittest.mock/_MockFailureHandler"},"kind":"variable","name":"_mockFailureHandler","id":"_mockFailureHandler","isPrivate":true,"line":"166"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"kind":"class","name":"Mock","id":"Mock","comment":"The base class for all mocked objects. ","children":[{"isSetter":true,"kind":"method","name":"logging=","id":"logging=1()","children":[{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"param","name":"value","id":"value"}],"line":"1268"},{"returnType":{"name":"Behavior","refId":"unittest.mock/Behavior"},"kind":"method","name":"when","id":"when1()","comment":"\n[when] is used to create a new or extend an existing [Behavior].\nA [CallMatcher] [filter] must be supplied, and the [Behavior]s for\nthat signature are returned (being created first if needed).\n\nTypical use case:\n\n    mock.when(callsTo(...)).alwaysReturn(...);\n","children":[{"ref":{"name":"CallMatcher","refId":"unittest.mock/CallMatcher"},"kind":"param","name":"logFilter","id":"logFilter"}],"line":"1325"},{"kind":"method","name":"noSuchMethod","id":"noSuchMethod1()","comment":"\nThis is the handler for method calls. We loop through the list\nof [Behavior]s, and find the first match that still has return\nvalues available, and then do the action specified by that\nreturn value. If we find no [Behavior] to apply an exception is\nthrown.\n","children":[{"ref":{"name":"Invocation","refId":"dart.core/Invocation"},"kind":"param","name":"invocation","id":"invocation"}],"line":"1343"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"kind":"method","name":"verifyZeroInteractions","id":"verifyZeroInteractions0()","comment":"[verifyZeroInteractions] returns true if no calls were made ","line":"1473"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"getLogs","id":"getLogs3()","comment":"\n[getLogs] extracts all calls from the call log that match the\n[logFilter], and returns the matching list of [LogEntry]s. If\n[destructive] is false (the default) the matching calls are left\nin the log, else they are removed. Removal allows us to verify a\nset of interactions and then verify that there are no other\ninteractions left. [actionMatcher] can be used to further\nrestrict the returned logs based on the action the mock performed.\n[logFilter] can be a [CallMatcher] or a predicate function that\ntakes a [LogEntry] and returns a bool.\n\nTypical usage:\n\n    getLogs(callsTo(...)).verify(...);\n","children":[{"ref":{"name":"CallMatcher","refId":"unittest.mock/CallMatcher"},"isOptional":true,"kind":"param","name":"logFilter","id":"logFilter"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"isOptional":true,"kind":"param","name":"actionMatcher","id":"actionMatcher","line":"1499"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"destructive","id":"destructive","line":"1500"}],"line":"1498"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"calls","id":"calls11()","comment":"\nUseful shorthand method that creates a [CallMatcher] from its arguments\nand then calls [getLogs].\n","children":[{"kind":"param","name":"method","id":"method"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg0","id":"arg0","line":"1516"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg1","id":"arg1","line":"1517"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg2","id":"arg2","line":"1518"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg3","id":"arg3","line":"1519"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg4","id":"arg4","line":"1520"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg5","id":"arg5","line":"1521"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg6","id":"arg6","line":"1522"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg7","id":"arg7","line":"1523"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg8","id":"arg8","line":"1524"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg9","id":"arg9","line":"1525"}],"line":"1515"},{"returnType":{"name":"void","refId":"void"},"kind":"method","name":"resetBehavior","id":"resetBehavior0()","comment":"Clear the behaviors for the Mock. ","line":"1530"},{"returnType":{"name":"void","refId":"void"},"kind":"method","name":"clearLogs","id":"clearLogs0()","comment":"Clear the logs for the Mock. ","line":"1533"},{"returnType":{"name":"void","refId":"void"},"kind":"method","name":"reset","id":"reset0()","comment":"Clear both logs and behavior. ","line":"1544"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"property","name":"logging","id":"logging","line":"1267"},{"ref":{"name":"String","refId":"dart.core/String"},"isFinal":true,"kind":"variable","name":"name","id":"name","comment":"The mock name. Needed if the log is shared; optional otherwise. ","line":"1250"},{"ref":{"name":"LinkedHashMap","refId":"dart.collection/LinkedHashMap","arguments":[{"name":"String","refId":"dart.core/String"},{"name":"Behavior","refId":"unittest.mock/Behavior"}]},"kind":"variable","name":"_behaviors","id":"_behaviors","comment":"The set of [Behavior]s supported. ","isPrivate":true,"line":"1253"},{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"variable","name":"log","id":"log","comment":"The [log] of calls made. Only used if [name] is null. ","line":"1256"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isFinal":true,"kind":"variable","name":"_throwIfNoBehavior","id":"_throwIfNoBehavior","comment":"How to handle unknown method calls - swallow or throw. ","isPrivate":true,"line":"1259"},{"ref":{"name":"Object","refId":"dart.core/Object"},"kind":"variable","name":"_realObject","id":"_realObject","comment":"For spys, the real object that we are spying on. ","isPrivate":true,"line":"1262"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"variable","name":"_logging","id":"_logging","comment":"Whether to create an audit log or not. ","isPrivate":true,"line":"1265"},{"kind":"constructor","name":"","id":"0()","comment":"\nDefault constructor. Unknown method calls are allowed and logged,\nthe mock has no name, and has its own log.\n","line":"1279"},{"kind":"constructor","name":"custom","id":"custom4()","comment":"\nThis constructor makes a mock that has a [name] and possibly uses\na shared [log]. If [throwIfNoBehavior] is true, any calls to methods\nthat have no defined behaviors will throw an exception; otherwise they\nwill be allowed and logged (but will not do anything).\nIf [enableLogging] is false, no logging will be done initially (whether\nor not a [log] is supplied), but [logging] can be set to true later.\n","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"isNamed":true,"initializedField":{"name":"name","refId":"unittest.mock/Mock/name"},"kind":"param","name":"name","id":"name"},{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"isOptional":true,"isNamed":true,"initializedField":{"name":"log","refId":"unittest.mock/Mock/log"},"kind":"param","name":"log","id":"log","line":"1293"},{"defaultValue":"false","isOptional":true,"isNamed":true,"kind":"param","name":"throwIfNoBehavior","id":"throwIfNoBehavior","line":"1294"},{"defaultValue":"true","isOptional":true,"isNamed":true,"kind":"param","name":"enableLogging","id":"enableLogging","line":"1295"}],"line":"1292"},{"kind":"constructor","name":"spy","id":"spy3()","comment":"\nThis constructor creates a spy with no user-defined behavior.\nThis is simply a proxy for a real object that passes calls\nthrough to that real object but captures an audit trail of\ncalls made to the object that can be queried and validated\nlater.\n","children":[{"ref":{"name":"Object","refId":"dart.core/Object"},"initializedField":{"name":"_realObject","refId":"unittest.mock/Mock/_realObject"},"kind":"param","name":"_realObject","id":"_realObject","isPrivate":true},{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"isNamed":true,"initializedField":{"name":"name","refId":"unittest.mock/Mock/name"},"kind":"param","name":"name","id":"name"},{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"isOptional":true,"isNamed":true,"initializedField":{"name":"log","refId":"unittest.mock/Mock/log"},"kind":"param","name":"log","id":"log"}],"line":"1310"}],"line":"1247"},{"superclass":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"class","name":"_ResultSetMatcher","id":"_ResultSetMatcher","comment":"\n[_ResultSetMatcher]s are used to make assertions about the results\nof method calls. When filtering an execution log by calling\n[getLogs], a [LogEntrySet] of matching call logs is returned;\n[_ResultSetMatcher]s can then assert various things about this\n(sub)set of logs.\n\nWe could make this class use _ResultMatcher but it doesn't buy that\nmatch and adds some perf hit, so there is some duplication here.\n","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"kind":"method","name":"matches","id":"matches2()","children":[{"kind":"param","name":"logList","id":"logList"},{"ref":{"name":"Map","refId":"dart.core/Map"},"kind":"param","name":"matchState","id":"matchState"}],"line":"1142"},{"returnType":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"method","name":"describe","id":"describe1()","children":[{"ref":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"param","name":"description","id":"description"}],"line":"1170"},{"returnType":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"method","name":"describeMismatch","id":"describeMismatch4()","children":[{"kind":"param","name":"logList","id":"logList"},{"ref":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"param","name":"mismatchDescription","id":"mismatchDescription"},{"ref":{"name":"Map","refId":"dart.core/Map"},"kind":"param","name":"matchState","id":"matchState","line":"1182"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"param","name":"verbose","id":"verbose","line":"1182"}],"line":"1181"},{"ref":{"name":"Action","refId":"unittest.mock/Action"},"isFinal":true,"kind":"variable","name":"action","id":"action","line":"1136"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"isFinal":true,"kind":"variable","name":"value","id":"value","line":"1137"},{"ref":{"name":"_Frequency","refId":"unittest.mock/_Frequency"},"isFinal":true,"kind":"variable","name":"frequency","id":"frequency","line":"1138"},{"kind":"constructor","name":"","id":"3()","children":[{"ref":{"name":"Action","refId":"unittest.mock/Action"},"initializedField":{"name":"action","refId":"unittest.mock/_ResultSetMatcher/action"},"kind":"param","name":"action","id":"action"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"initializedField":{"name":"value","refId":"unittest.mock/_ResultSetMatcher/value"},"kind":"param","name":"value","id":"value"},{"ref":{"name":"_Frequency","refId":"unittest.mock/_Frequency"},"initializedField":{"name":"frequency","refId":"unittest.mock/_ResultSetMatcher/frequency"},"kind":"param","name":"frequency","id":"frequency"}],"line":"1140"}],"isPrivate":true,"line":"1135"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"kind":"class","name":"_Frequency","id":"_Frequency","comment":"Special values for use with [_ResultSetMatcher] [frequency]. ","children":[{"isStatic":true,"kind":"variable","name":"ALL","id":"ALL","comment":"Every call/throw must match ","line":"1112"},{"isStatic":true,"kind":"variable","name":"SOME","id":"SOME","comment":"At least one call/throw must match. ","line":"1115"},{"isStatic":true,"kind":"variable","name":"NONE","id":"NONE","comment":"No calls/throws should match. ","line":"1118"},{"ref":{"name":"String","refId":"dart.core/String"},"isFinal":true,"kind":"variable","name":"name","id":"name","line":"1122"},{"kind":"constructor","name":"_","id":"_1()","children":[{"ref":{"name":"String","refId":"dart.core/String"},"initializedField":{"name":"name","refId":"unittest.mock/_Frequency/name"},"kind":"param","name":"name","id":"name"}],"isPrivate":true,"line":"1120"}],"isPrivate":true,"line":"1110"},{"superclass":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"class","name":"_ResultMatcher","id":"_ResultMatcher","comment":"\n[_ResultMatcher]s are used to make assertions about the results\nof method calls. These can be used as optional parameters to [getLogs].\n","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"kind":"method","name":"matches","id":"matches2()","children":[{"kind":"param","name":"item","id":"item"},{"ref":{"name":"Map","refId":"dart.core/Map"},"kind":"param","name":"matchState","id":"matchState"}],"line":"1062"},{"returnType":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"method","name":"describe","id":"describe1()","children":[{"ref":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"param","name":"description","id":"description"}],"line":"1074"},{"returnType":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"method","name":"describeMismatch","id":"describeMismatch4()","children":[{"kind":"param","name":"item","id":"item"},{"ref":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"param","name":"mismatchDescription","id":"mismatchDescription"},{"ref":{"name":"Map","refId":"dart.core/Map"},"kind":"param","name":"matchState","id":"matchState","line":"1084"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"param","name":"verbose","id":"verbose","line":"1084"}],"line":"1083"},{"ref":{"name":"Action","refId":"unittest.mock/Action"},"isFinal":true,"kind":"variable","name":"action","id":"action","line":"1057"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"isFinal":true,"kind":"variable","name":"value","id":"value","line":"1058"},{"kind":"constructor","name":"","id":"2()","children":[{"ref":{"name":"Action","refId":"unittest.mock/Action"},"initializedField":{"name":"action","refId":"unittest.mock/_ResultMatcher/action"},"kind":"param","name":"action","id":"action"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"initializedField":{"name":"value","refId":"unittest.mock/_ResultMatcher/value"},"kind":"param","name":"value","id":"value"}],"line":"1060"}],"isPrivate":true,"line":"1056"},{"superclass":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"class","name":"_TimesMatcher","id":"_TimesMatcher","comment":"\n[_TimesMatcher]s are used to make assertions about the number of\ntimes a method was called.\n","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"kind":"method","name":"matches","id":"matches2()","children":[{"kind":"param","name":"logList","id":"logList"},{"ref":{"name":"Map","refId":"dart.core/Map"},"kind":"param","name":"matchState","id":"matchState"}],"line":"1003"},{"returnType":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"method","name":"describe","id":"describe1()","children":[{"ref":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"param","name":"description","id":"description"}],"line":"1006"},{"returnType":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"method","name":"describeMismatch","id":"describeMismatch4()","children":[{"kind":"param","name":"logList","id":"logList"},{"ref":{"name":"Description","refId":"unittest.matcher/Description"},"kind":"param","name":"mismatchDescription","id":"mismatchDescription"},{"ref":{"name":"Map","refId":"dart.core/Map"},"kind":"param","name":"matchState","id":"matchState","line":"1021"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"param","name":"verbose","id":"verbose","line":"1021"}],"line":"1020"},{"ref":{"name":"int","refId":"dart.core/int"},"isFinal":true,"kind":"variable","name":"min","id":"min","line":"999"},{"ref":{"name":"int","refId":"dart.core/int"},"isFinal":true,"kind":"variable","name":"max","id":"max","line":"999"},{"kind":"constructor","name":"","id":"2()","children":[{"ref":{"name":"int","refId":"dart.core/int"},"initializedField":{"name":"min","refId":"unittest.mock/_TimesMatcher/min"},"kind":"param","name":"min","id":"min"},{"ref":{"name":"int","refId":"dart.core/int"},"defaultValue":"-1","isOptional":true,"initializedField":{"name":"max","refId":"unittest.mock/_TimesMatcher/max"},"kind":"param","name":"max","id":"max"}],"line":"1001"}],"isPrivate":true,"line":"998"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"kind":"class","name":"LogEntryList","id":"LogEntryList","comment":"\nWe do verification on a list of [LogEntry]s. To allow chaining\nof calls to verify, we encapsulate such a list in the [LogEntryList]\nclass.\n","children":[{"kind":"method","name":"add","id":"add1()","comment":"Add a [LogEntry] to the log. ","children":[{"ref":{"name":"LogEntry","refId":"unittest.mock/LogEntry"},"kind":"param","name":"entry","id":"entry"}],"line":"499"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"kind":"method","name":"_makePredicate","id":"_makePredicate1()","comment":"Creates a LogEntry predicate function from the argument. ","children":[{"kind":"param","name":"arg","id":"arg"}],"isPrivate":true,"line":"508"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"getMatches","id":"getMatches4()","comment":"\nCreate a new [LogEntryList] consisting of [LogEntry]s from\nthis list that match the specified [mockNameFilter] and [logFilter].\n[mockNameFilter] can be null, a [String], a predicate [Function],\nor a [Matcher]. If [mockNameFilter] is null, this is the same as\n[anything].\nIf [logFilter] is null, all entries in the log will be returned.\nOtherwise [logFilter] should be a [CallMatcher] or  predicate function\nthat takes a [LogEntry] and returns a bool.\nIf [destructive] is true, the log entries are removed from the\noriginal list.\n","children":[{"isOptional":true,"kind":"param","name":"mockNameFilter","id":"mockNameFilter"},{"isOptional":true,"kind":"param","name":"logFilter","id":"logFilter","line":"533"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"isOptional":true,"kind":"param","name":"actionMatcher","id":"actionMatcher","line":"534"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"destructive","id":"destructive","line":"535"}],"line":"532"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"verify","id":"verify1()","comment":"Apply a unit test [Matcher] to the [LogEntryList]. ","children":[{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"param","name":"matcher","id":"matcher"}],"line":"563"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"kind":"method","name":"stepwiseValidate","id":"stepwiseValidate2()","comment":"\nIterate through the list and call the [validator] function with the\nlog [List] and position. The [validator] should return the number of\npositions to advance upon success, or zero upon failure. When zero is\nreturned an error is reported. [reason] can be used to provide a\nmore descriptive failure message. If a failure occurred false will be\nreturned (unless the failure handler itself threw an exception);\notherwise true is returned.\nThe use case here is to perform more complex validations; for example\nwe may want to assert that the return value from some function is\nlater used as a parameter to a following function. If we filter the logs\nto include just these two functions we can write a simple validator to\ndo this check.\n","children":[{"ref":{"name":"StepValidator","refId":"unittest.mock/StepValidator"},"kind":"param","name":"validator","id":"validator"},{"ref":{"name":"String","refId":"dart.core/String"},"defaultValue":"''","isOptional":true,"kind":"param","name":"reason","id":"reason"}],"line":"586"},{"returnType":{"name":"String","refId":"dart.core/String"},"kind":"method","name":"toString","id":"toString1()","comment":"\nTurn the logs into human-readable text. If [baseTime] is specified\nthen each entry is prefixed with the offset from that time in\nmilliseconds; otherwise the time of day is used.\n","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"isOptional":true,"kind":"param","name":"baseTime","id":"baseTime"}],"line":"613"},{"returnType":{"name":"int","refId":"dart.core/int"},"kind":"method","name":"findLogEntry","id":"findLogEntry4()","comment":"\n Find the first log entry that satisfies [logFilter] and\n return its position. A search [start] position can be provided\n to allow for repeated searches. [logFilter] can be a [CallMatcher],\n or a predicate function that takes a [LogEntry] argument and returns\n a bool. If [logFilter] is null, it will match any [LogEntry].\n If no entry is found, then [failureReturnValue] is returned.\n After each check the position is updated by [skip], so using\n [skip] of -1 allows backward searches, using a [skip] of 2 can\n be used to check pairs of adjacent entries, and so on.\n","children":[{"kind":"param","name":"logFilter","id":"logFilter"},{"ref":{"name":"int","refId":"dart.core/int"},"defaultValue":"0","isOptional":true,"kind":"param","name":"start","id":"start"},{"ref":{"name":"int","refId":"dart.core/int"},"defaultValue":"-1","isOptional":true,"kind":"param","name":"failureReturnValue","id":"failureReturnValue"},{"defaultValue":"1","isOptional":true,"kind":"param","name":"skip","id":"skip","line":"633"}],"line":"632"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"_head","id":"_head4()","comment":"\nReturns log events that happened up to the first one that\nsatisfies [logFilter]. If [inPlace] is true, then returns\nthis LogEntryList after removing the from the first satisfier;\nonwards otherwise a new list is created. [description]\nis used to create a new name for the resulting list.\n[defaultPosition] is used as the index of the matching item in\nthe case that no match is found.\n","children":[{"kind":"param","name":"logFilter","id":"logFilter"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"param","name":"inPlace","id":"inPlace"},{"ref":{"name":"String","refId":"dart.core/String"},"kind":"param","name":"description","id":"description","line":"655"},{"ref":{"name":"int","refId":"dart.core/int"},"kind":"param","name":"defaultPosition","id":"defaultPosition","line":"655"}],"isPrivate":true,"line":"654"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"_tail","id":"_tail4()","comment":"\nReturns log events that happened from the first one that\nsatisfies [logFilter]. If [inPlace] is true, then returns\nthis LogEntryList after removing the entries up to the first\nsatisfier; otherwise a new list is created. [description]\nis used to create a new name for the resulting list.\n[defaultPosition] is used as the index of the matching item in\nthe case that no match is found.\n","children":[{"kind":"param","name":"logFilter","id":"logFilter"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"param","name":"inPlace","id":"inPlace"},{"ref":{"name":"String","refId":"dart.core/String"},"kind":"param","name":"description","id":"description","line":"685"},{"ref":{"name":"int","refId":"dart.core/int"},"kind":"param","name":"defaultPosition","id":"defaultPosition","line":"685"}],"isPrivate":true,"line":"684"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"after","id":"after2()","comment":"\nReturns log events that happened after [when]. If [inPlace]\nis true, then it returns this LogEntryList after removing\nthe entries that happened up to [when]; otherwise a new\nlist is created.\n","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"kind":"param","name":"when","id":"when"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"711"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"from","id":"from2()","comment":"\nReturns log events that happened from [when] onwards. If\n[inPlace] is true, then it returns this LogEntryList after\nremoving the entries that happened before [when]; otherwise\na new list is created.\n","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"kind":"param","name":"when","id":"when"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"720"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"until","id":"until2()","comment":"\nReturns log events that happened until [when]. If [inPlace]\nis true, then it returns this LogEntryList after removing\nthe entries that happened after [when]; otherwise a new\nlist is created.\n","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"kind":"param","name":"when","id":"when"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"729"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"before","id":"before2()","comment":"\nReturns log events that happened before [when]. If [inPlace]\nis true, then it returns this LogEntryList after removing\nthe entries that happened from [when] onwards; otherwise a new\nlist is created.\n","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"kind":"param","name":"when","id":"when"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"738"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"afterEntry","id":"afterEntry2()","comment":"\nReturns log events that happened after [logEntry]'s time.\nIf [inPlace] is true, then it returns this LogEntryList after\nremoving the entries that happened up to [when]; otherwise a new\nlist is created. If [logEntry] is null the current time is used.\n","children":[{"ref":{"name":"LogEntry","refId":"unittest.mock/LogEntry"},"kind":"param","name":"logEntry","id":"logEntry"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"750"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"fromEntry","id":"fromEntry2()","comment":"\nReturns log events that happened from [logEntry]'s time onwards.\nIf [inPlace] is true, then it returns this LogEntryList after\nremoving the entries that happened before [when]; otherwise\na new list is created. If [logEntry] is null the current time is used.\n","children":[{"ref":{"name":"LogEntry","refId":"unittest.mock/LogEntry"},"kind":"param","name":"logEntry","id":"logEntry"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"759"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"untilEntry","id":"untilEntry2()","comment":"\nReturns log events that happened until [logEntry]'s time. If\n[inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened after [when]; otherwise a new\nlist is created. If [logEntry] is null the epoch time is used.\n","children":[{"ref":{"name":"LogEntry","refId":"unittest.mock/LogEntry"},"kind":"param","name":"logEntry","id":"logEntry"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"768"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"beforeEntry","id":"beforeEntry2()","comment":"\nReturns log events that happened before [logEntry]'s time. If\n[inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened from [when] onwards; otherwise a new\nlist is created. If [logEntry] is null the epoch time is used.\n","children":[{"ref":{"name":"LogEntry","refId":"unittest.mock/LogEntry"},"kind":"param","name":"logEntry","id":"logEntry"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"778"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"afterFirst","id":"afterFirst2()","comment":"\nReturns log events that happened after the first event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened earlier; otherwise a new list is created.\n","children":[{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"param","name":"segment","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"787"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"afterLast","id":"afterLast2()","comment":"\nReturns log events that happened after the last event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened earlier; otherwise a new list is created.\n","children":[{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"param","name":"segment","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"795"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"fromFirst","id":"fromFirst2()","comment":"\nReturns log events that happened from the time of the first event in\n[segment] onwards. If [inPlace] is true, then it returns this\nLogEntryList after removing the earlier entries; otherwise a new list\nis created.\n","children":[{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"param","name":"segment","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"804"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"fromLast","id":"fromLast2()","comment":"\nReturns log events that happened from the time of the last event in\n[segment] onwards. If [inPlace] is true, then it returns this\nLogEntryList after removing the earlier entries; otherwise a new list\nis created.\n","children":[{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"param","name":"segment","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"813"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"untilFirst","id":"untilFirst2()","comment":"\nReturns log events that happened until the first event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.\n","children":[{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"param","name":"segment","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"821"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"untilLast","id":"untilLast2()","comment":"\nReturns log events that happened until the last event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.\n","children":[{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"param","name":"segment","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"829"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"beforeFirst","id":"beforeFirst2()","comment":"\nReturns log events that happened before the first event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.\n","children":[{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"param","name":"segment","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"837"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"beforeLast","id":"beforeLast2()","comment":"\nReturns log events that happened before the last event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.\n","children":[{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"param","name":"segment","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"kind":"param","name":"inPlace","id":"inPlace"}],"line":"845"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"_neighboring","id":"_neighboring6()","comment":"\nIterate through the LogEntryList looking for matches to the entries\nin [keys]; for each match found the closest [distance] neighboring log\nentries that match [mockNameFilter] and [logFilter] will be included in\nthe result. If [isPreceding] is true we use the neighbors that precede\nthe matched entry; else we use the neighbors that followed.\nIf [includeKeys] is true then the entries in [keys] that resulted in\nentries in the output list are themselves included in the output list. If\n[distance] is zero then all matches are included.\n","children":[{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"param","name":"isPreceding","id":"isPreceding"},{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"param","name":"keys","id":"keys","line":"859"},{"kind":"param","name":"mockNameFilter","id":"mockNameFilter","line":"860"},{"kind":"param","name":"logFilter","id":"logFilter","line":"861"},{"ref":{"name":"int","refId":"dart.core/int"},"kind":"param","name":"distance","id":"distance","line":"862"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"param","name":"includeKeys","id":"includeKeys","line":"863"}],"isPrivate":true,"line":"858"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"preceding","id":"preceding5()","comment":"\nIterate through the LogEntryList looking for matches to the entries\nin [keys]; for each match found the closest [distance] prior log entries\nthat match [mocknameFilter] and [logFilter] will be included in the result.\nIf [includeKeys] is true then the entries in [keys] that resulted in\nentries in the output list are themselves included in the output list. If\n[distance] is zero then all matches are included.\n\nThe idea here is that you could find log entries that are related to\nother logs entries in some temporal sense. For example, say we have a\nmethod commit() that returns -1 on failure. Before commit() gets called\nthe value being committed is created by process(). We may want to find\nthe calls to process() that preceded calls to commit() that failed.\nWe could do this with:\n\n     print(log.preceding(log.getLogs(callsTo('commit'), returning(-1)),\n         logFilter: callsTo('process')).toString());\n\nWe might want to include the details of the failing calls to commit()\nto see what parameters were passed in, in which case we would set\n[includeKeys].\n\nAs another simple example, say we wanted to know the three method\ncalls that immediately preceded each failing call to commit():\n\n    print(log.preceding(log.getLogs(callsTo('commit'), returning(-1)),\n        distance: 3).toString());\n","children":[{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"param","name":"keys","id":"keys"},{"defaultValue":"null","isOptional":true,"isNamed":true,"kind":"param","name":"mockNameFilter","id":"mockNameFilter","line":"969"},{"defaultValue":"null","isOptional":true,"isNamed":true,"kind":"param","name":"logFilter","id":"logFilter","line":"970"},{"ref":{"name":"int","refId":"dart.core/int"},"defaultValue":"1","isOptional":true,"isNamed":true,"kind":"param","name":"distance","id":"distance","line":"971"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"isNamed":true,"kind":"param","name":"includeKeys","id":"includeKeys","line":"972"}],"line":"968"},{"returnType":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"method","name":"following","id":"following5()","comment":"\nIterate through the LogEntryList looking for matches to the entries\nin [keys]; for each match found the closest [distance] subsequent log\nentries that match [mocknameFilter] and [logFilter] will be included in\nthe result. If [includeKeys] is true then the entries in [keys] that\nresulted in entries in the output list are themselves included in the\noutput list. If [distance] is zero then all matches are included.\nSee [preceding] for a usage example.\n","children":[{"ref":{"name":"LogEntryList","refId":"unittest.mock/LogEntryList"},"kind":"param","name":"keys","id":"keys"},{"defaultValue":"null","isOptional":true,"isNamed":true,"kind":"param","name":"mockNameFilter","id":"mockNameFilter","line":"986"},{"defaultValue":"null","isOptional":true,"isNamed":true,"kind":"param","name":"logFilter","id":"logFilter","line":"987"},{"ref":{"name":"int","refId":"dart.core/int"},"defaultValue":"1","isOptional":true,"isNamed":true,"kind":"param","name":"distance","id":"distance","line":"988"},{"ref":{"name":"bool","refId":"dart.core/bool"},"defaultValue":"false","isOptional":true,"isNamed":true,"kind":"param","name":"includeKeys","id":"includeKeys","line":"989"}],"line":"985"},{"kind":"property","name":"first","id":"first","comment":"Get the first entry, or null if no entries. ","line":"502"},{"kind":"property","name":"last","id":"last","comment":"Get the last entry, or null if no entries. ","line":"505"},{"ref":{"name":"String","refId":"dart.core/String"},"kind":"variable","name":"filter","id":"filter","line":"492"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"LogEntry","refId":"unittest.mock/LogEntry"}]},"kind":"variable","name":"logs","id":"logs","line":"493"},{"kind":"constructor","name":"","id":"1()","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"initializedField":{"name":"filter","refId":"unittest.mock/LogEntryList/filter"},"kind":"param","name":"filter","id":"filter"}],"line":"494"}],"line":"491"},{"returnType":{"name":"int","refId":"dart.core/int"},"kind":"typedef","name":"StepValidator","id":"StepValidator","comment":"\n[StepValidator]s are used by [stepwiseValidate] in [LogEntryList], which\niterates through the list and call the [StepValidator] function with the\nlog [List] and position. The [StepValidator] should return the number of\npositions to advance upon success, or zero upon failure. When zero is\nreturned an error is reported.\n","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"LogEntry","refId":"unittest.mock/LogEntry"}]},"kind":"param","name":"logs","id":"logs"},{"ref":{"name":"int","refId":"dart.core/int"},"kind":"param","name":"pos","id":"pos"}],"line":"484"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"kind":"class","name":"LogEntry","id":"LogEntry","comment":"\nEvery call to a [Mock] object method is logged. The logs are\nkept in instances of [LogEntry].\n","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"kind":"method","name":"_pad2","id":"_pad21()","children":[{"ref":{"name":"int","refId":"dart.core/int"},"kind":"param","name":"val","id":"val"}],"isPrivate":true,"line":"434"},{"returnType":{"name":"String","refId":"dart.core/String"},"kind":"method","name":"toString","id":"toString1()","children":[{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"isOptional":true,"kind":"param","name":"baseTime","id":"baseTime"}],"line":"436"},{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"kind":"variable","name":"time","id":"time","comment":"The time of the event. ","line":"412"},{"ref":{"name":"String","refId":"dart.core/String"},"isFinal":true,"kind":"variable","name":"mockName","id":"mockName","comment":"The mock object name, if any. ","line":"415"},{"ref":{"name":"String","refId":"dart.core/String"},"isFinal":true,"kind":"variable","name":"methodName","id":"methodName","comment":"The method name. ","line":"418"},{"ref":{"name":"List","refId":"dart.core/List"},"isFinal":true,"kind":"variable","name":"args","id":"args","comment":"The parameters. ","line":"421"},{"ref":{"name":"Action","refId":"unittest.mock/Action"},"isFinal":true,"kind":"variable","name":"action","id":"action","comment":"The behavior that resulted. ","line":"424"},{"isFinal":true,"kind":"variable","name":"value","id":"value","comment":"The value that was returned (if no throw). ","line":"427"},{"kind":"constructor","name":"","id":"5()","children":[{"ref":{"name":"String","refId":"dart.core/String"},"initializedField":{"name":"mockName","refId":"unittest.mock/LogEntry/mockName"},"kind":"param","name":"mockName","id":"mockName"},{"ref":{"name":"String","refId":"dart.core/String"},"initializedField":{"name":"methodName","refId":"unittest.mock/LogEntry/methodName"},"kind":"param","name":"methodName","id":"methodName"},{"ref":{"name":"List","refId":"dart.core/List"},"initializedField":{"name":"args","refId":"unittest.mock/LogEntry/args"},"kind":"param","name":"args","id":"args","line":"430"},{"ref":{"name":"Action","refId":"unittest.mock/Action"},"initializedField":{"name":"action","refId":"unittest.mock/LogEntry/action"},"kind":"param","name":"action","id":"action","line":"430"},{"isOptional":true,"initializedField":{"name":"value","refId":"unittest.mock/LogEntry/value"},"kind":"param","name":"value","id":"value","line":"430"}],"line":"429"}],"line":"410"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"kind":"class","name":"Behavior","id":"Behavior","comment":"\nA [Behavior] represents how a [Mock] will respond to one particular\ntype of method call.\n","children":[{"returnType":{"name":"Behavior","refId":"unittest.mock/Behavior"},"kind":"method","name":"thenReturn","id":"thenReturn2()","comment":"\nAdds a [Responder] that returns a [value] for [count] calls\n(1 by default).\n","children":[{"kind":"param","name":"value","id":"value"},{"defaultValue":"1","isOptional":true,"kind":"param","name":"count","id":"count"}],"line":"349"},{"returnType":{"name":"Behavior","refId":"unittest.mock/Behavior"},"kind":"method","name":"alwaysReturn","id":"alwaysReturn1()","comment":"Adds a [Responder] that repeatedly returns a [value]. ","children":[{"kind":"param","name":"value","id":"value"}],"line":"355"},{"returnType":{"name":"Behavior","refId":"unittest.mock/Behavior"},"kind":"method","name":"thenThrow","id":"thenThrow2()","comment":"\nAdds a [Responder] that throws [value] [count]\ntimes (1 by default).\n","children":[{"kind":"param","name":"value","id":"value"},{"defaultValue":"1","isOptional":true,"kind":"param","name":"count","id":"count"}],"line":"363"},{"returnType":{"name":"Behavior","refId":"unittest.mock/Behavior"},"kind":"method","name":"alwaysThrow","id":"alwaysThrow1()","comment":"Adds a [Responder] that throws [value] endlessly. ","children":[{"kind":"param","name":"value","id":"value"}],"line":"369"},{"returnType":{"name":"Behavior","refId":"unittest.mock/Behavior"},"kind":"method","name":"thenCall","id":"thenCall2()","comment":"\n[thenCall] creates a proxy Responder, that is called [count]\ntimes (1 by default; 0 is used for unlimited calls, and is\nexposed as [alwaysCall]). [value] is the function that will\nbe called with the same arguments that were passed to the\nmock. Proxies can be used to wrap real objects or to define\nmore complex return/throw behavior. You could even (if you\nwanted) use proxies to emulate the behavior of thenReturn;\ne.g.:\n\n    m.when(callsTo('foo')).thenReturn(0)\n\nis equivalent to:\n\n    m.when(callsTo('foo')).thenCall(() => 0)\n","children":[{"kind":"param","name":"value","id":"value"},{"defaultValue":"1","isOptional":true,"kind":"param","name":"count","id":"count"}],"line":"389"},{"returnType":{"name":"Behavior","refId":"unittest.mock/Behavior"},"kind":"method","name":"alwaysCall","id":"alwaysCall1()","comment":"Creates a repeating proxy call. ","children":[{"kind":"param","name":"value","id":"value"}],"line":"395"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"kind":"method","name":"matches","id":"matches2()","comment":"Returns true if a method call matches the [Behavior]. ","children":[{"ref":{"name":"String","refId":"dart.core/String"},"kind":"param","name":"method","id":"method"},{"ref":{"name":"List","refId":"dart.core/List"},"kind":"param","name":"args","id":"args"}],"line":"400"},{"returnType":{"name":"String","refId":"dart.core/String"},"kind":"method","name":"toString","id":"toString0()","comment":"Returns the [matcher]'s representation. ","line":"403"},{"ref":{"name":"CallMatcher","refId":"unittest.mock/CallMatcher"},"kind":"variable","name":"matcher","id":"matcher","line":"337"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Responder","refId":"unittest.mock/Responder"}]},"kind":"variable","name":"actions","id":"actions","line":"338"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"variable","name":"logging","id":"logging","line":"339"},{"kind":"constructor","name":"","id":"1()","children":[{"ref":{"name":"CallMatcher","refId":"unittest.mock/CallMatcher"},"initializedField":{"name":"matcher","refId":"unittest.mock/Behavior/matcher"},"kind":"param","name":"matcher","id":"matcher"}],"line":"341"}],"line":"336"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"kind":"class","name":"CallMatcher","id":"CallMatcher","comment":"\nA [CallMatcher] is a special matcher used to match method calls (i.e.\na method name and set of arguments). It is not a [Matcher] like the\nunit test [Matcher], but instead represents a method name and a\ncollection of [Matcher]s, one per argument, that will be applied\nto the parameters to decide if the method call is a match.\n","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"kind":"method","name":"toString","id":"toString0()","comment":"\nWe keep our behavior specifications in a Map, which is keyed\nby the [CallMatcher]. To make the keys unique and to get a\ndescriptive value for the [CallMatcher] we have this override\nof [toString()].\n","line":"269"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"kind":"method","name":"matches","id":"matches2()","comment":"\nGiven a [method] name and list of [arguments], return true\nif it matches this [CallMatcher.\n","children":[{"ref":{"name":"String","refId":"dart.core/String"},"kind":"param","name":"method","id":"method"},{"ref":{"name":"List","refId":"dart.core/List"},"kind":"param","name":"arguments","id":"arguments"}],"line":"290"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"variable","name":"nameFilter","id":"nameFilter","line":"215"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Matcher","refId":"unittest.matcher/Matcher"}]},"kind":"variable","name":"argMatchers","id":"argMatchers","line":"216"},{"kind":"constructor","name":"","id":"11()","comment":"\nConstructor for [CallMatcher]. [name] can be null to\nmatch anything, or a literal [String], a predicate [Function],\nor a [Matcher]. The various arguments can be scalar values or\n[Matcher]s.\n","children":[{"isOptional":true,"kind":"param","name":"name","id":"name"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg0","id":"arg0","line":"225"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg1","id":"arg1","line":"226"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg2","id":"arg2","line":"227"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg3","id":"arg3","line":"228"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg4","id":"arg4","line":"229"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg5","id":"arg5","line":"230"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg6","id":"arg6","line":"231"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg7","id":"arg7","line":"232"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg8","id":"arg8","line":"233"},{"defaultValue":"_noArg","isOptional":true,"kind":"param","name":"arg9","id":"arg9","line":"234"}],"line":"224"}],"line":"214"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"kind":"class","name":"Responder","id":"Responder","comment":"\nThe behavior of a method call in the mock library is specified\nwith [Responder]s. A [Responder] has a [value] to throw\nor return (depending on the type of [action]),\nand can either be one-shot, multi-shot, or infinitely repeating,\ndepending on the value of [count (1, greater than 1, or 0 respectively).\n","children":[{"kind":"variable","name":"value","id":"value","line":"201"},{"ref":{"name":"Action","refId":"unittest.mock/Action"},"kind":"variable","name":"action","id":"action","line":"202"},{"ref":{"name":"int","refId":"dart.core/int"},"kind":"variable","name":"count","id":"count","line":"203"},{"kind":"constructor","name":"","id":"3()","children":[{"initializedField":{"name":"value","refId":"unittest.mock/Responder/value"},"kind":"param","name":"value","id":"value"},{"ref":{"name":"int","refId":"dart.core/int"},"defaultValue":"1","isOptional":true,"initializedField":{"name":"count","refId":"unittest.mock/Responder/count"},"kind":"param","name":"count","id":"count"},{"ref":{"name":"Action","refId":"unittest.mock/Action"},"defaultValue":"Action.RETURN","isOptional":true,"initializedField":{"name":"action","refId":"unittest.mock/Responder/action"},"kind":"param","name":"action","id":"action"}],"line":"204"}],"line":"200"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"kind":"class","name":"Action","id":"Action","comment":"The ways in which a call to a mock method can be handled. ","children":[{"isStatic":true,"kind":"variable","name":"IGNORE","id":"IGNORE","comment":"Do nothing (void method) ","line":"177"},{"isStatic":true,"kind":"variable","name":"RETURN","id":"RETURN","comment":"Return a supplied value. ","line":"180"},{"isStatic":true,"kind":"variable","name":"THROW","id":"THROW","comment":"Throw a supplied value. ","line":"183"},{"isStatic":true,"kind":"variable","name":"PROXY","id":"PROXY","comment":"Call a supplied function. ","line":"186"},{"ref":{"name":"String","refId":"dart.core/String"},"isFinal":true,"kind":"variable","name":"name","id":"name","line":"190"},{"kind":"constructor","name":"_","id":"_1()","children":[{"ref":{"name":"String","refId":"dart.core/String"},"initializedField":{"name":"name","refId":"unittest.mock/Action/name"},"kind":"param","name":"name","id":"name"}],"isPrivate":true,"line":"188"}],"line":"175"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"kind":"class","name":"_Sentinel","id":"_Sentinel","comment":"Sentinel value for representing no argument. ","children":[{"kind":"constructor","name":"","id":"0()","line":"170"}],"isPrivate":true,"line":"169"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"interfaces":[{"name":"FailureHandler","refId":"unittest.matcher/FailureHandler"}],"kind":"class","name":"_MockFailureHandler","id":"_MockFailureHandler","comment":"\nThe failure handler for the [expect()] calls that occur in [verify()]\nmethods in the mock objects. This calls the real failure handler used\nby the unit test library after formatting the error message with\nthe custom formatter.\n","children":[{"returnType":{"name":"void","refId":"void"},"kind":"method","name":"fail","id":"fail1()","children":[{"ref":{"name":"String","refId":"dart.core/String"},"kind":"param","name":"reason","id":"reason"}],"line":"156"},{"returnType":{"name":"void","refId":"void"},"kind":"method","name":"failMatch","id":"failMatch5()","children":[{"kind":"param","name":"actual","id":"actual"},{"ref":{"name":"Matcher","refId":"unittest.matcher/Matcher"},"kind":"param","name":"matcher","id":"matcher"},{"ref":{"name":"String","refId":"dart.core/String"},"kind":"param","name":"reason","id":"reason"},{"ref":{"name":"Map","refId":"dart.core/Map"},"kind":"param","name":"matchState","id":"matchState","line":"160"},{"ref":{"name":"bool","refId":"dart.core/bool"},"kind":"param","name":"verbose","id":"verbose","line":"160"}],"line":"159"},{"ref":{"name":"FailureHandler","refId":"unittest.matcher/FailureHandler"},"kind":"variable","name":"proxy","id":"proxy","line":"154"},{"kind":"constructor","name":"","id":"1()","children":[{"ref":{"name":"FailureHandler","refId":"unittest.matcher/FailureHandler"},"initializedField":{"name":"proxy","refId":"unittest.mock/_MockFailureHandler/proxy"},"kind":"param","name":"proxy","id":"proxy"}],"line":"155"}],"isPrivate":true,"line":"153"}],"uri":"doc_diff/bin/packages/unittest/mock.dart","line":"125"}